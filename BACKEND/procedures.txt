-- procedure that lists books with filters applied
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS listBooksFiltered(
  IN title VARCHAR(255),
  IN genre VARCHAR(255),
  IN author VARCHAR(255),
  IN release_date VARCHAR(255),
  IN var_languages VARCHAR (255),
  IN var_ISBN VARCHAR(13),
  IN offseter INT,
  IN limiter INT
) BEGIN
CALL getBookById((SELECT
  GROUP_CONCAT(DISTINCT book.ISBN_id LIMIT limiter OFFSET offseter)
FROM
  book
  INNER JOIN (
    books_genres_conn
    INNER JOIN genres ON genres.genre_id = books_genres_conn.genre_id
  ) ON book.ISBN_id = books_genres_conn.ISBN_id
  INNER JOIN (
    books_authors_conn
    INNER JOIN authors ON authors.author_id = books_authors_conn.author_id
  ) ON book.ISBN_id = books_authors_conn.ISBN_id
  INNER JOIN publishers ON publishers.publisher_id = book.publisher_id
  INNER JOIN languages ON languages.lang_id = book.lang_id
  INNER JOIN inventory ON inventory.ISBN_id = book.ISBN_id
WHERE
  book.title LIKE CONCAT("%", title, "%")
  AND genres.genre LIKE CONCAT("%", genre, "%")
  AND authors.author LIKE CONCAT("%", author, "%")
  AND CAST(book.release_date AS VARCHAR(255)) LIKE CONCAT("%", release_date, "%")
  AND languages.lang LIKE CONCAT("%", var_languages, "%")
  AND book.ISBN LIKE CONCAT("%", var_ISBN, "%")
  AND inventory.available = TRUE

));
END;//
DELIMITER ;

-- get book by isbn
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getBookByISBN(
  IN ISBN VARCHAR(255)
) BEGIN
	CALL getBookById((SELECT book.ISBN_id FROM book WHERE book.ISBN = ISBN LIMIT 1));
END;//
DELIMITER ;

-- gets all genres
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getGenres(
) BEGIN
	SELECT genres.genre FROM genres;
END;//
DELIMITER ;

-- gets all languages
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getLangs(
) BEGIN
	SELECT * FROM languages;
END;//
DELIMITER ;

-- converts isbn to isbnid
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getIdFromISBN(
  IN ISBN VARCHAR(255)
) BEGIN
	SELECT book.ISBN_id FROM book WHERE book.ISBN = ISBN LIMIT 1;
END;//
DELIMITER ;

-- procedure, that gets every information abt a book by id
-- can be used for desktop app too
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getBookById(
  IN ID VARCHAR(255)
) BEGIN
SELECT
  book.ISBN_id, book.title, book.picture_base64, GROUP_CONCAT(DISTINCT genres.genre) AS `genres`, GROUP_CONCAT(DISTINCT authors.author) AS `authors`, publishers.name, book.release_date, languages.lang, book.ISBN, book.description
FROM
  book
  INNER JOIN (
    books_genres_conn
    INNER JOIN genres ON genres.genre_id = books_genres_conn.genre_id
  ) ON book.ISBN_id = books_genres_conn.ISBN_id
  INNER JOIN (
    books_authors_conn
    INNER JOIN authors ON authors.author_id = books_authors_conn.author_id
  ) ON book.ISBN_id = books_authors_conn.ISBN_id
  INNER JOIN publishers ON publishers.publisher_id = book.publisher_id
  INNER JOIN languages ON languages.lang_id = book.lang_id
WHERE
  FIND_IN_SET(CAST(book.ISBN_id AS VARCHAR(255)), ID)
GROUP BY 1;
END;//
DELIMITER ;

-- get all booked and reserved book by userID
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getBookedAndReservedBooks(
  IN ID INT
) BEGIN
(SELECT book.title AS 'title', GROUP_CONCAT(DISTINCT authors.author) AS 'authors', 'booking' AS 'status', book.ISBN, booking.booking_id as `id`, booking.`end_date` FROM booking INNER JOIN (inventory INNER JOIN (book INNER JOIN (books_authors_conn INNER JOIN authors ON books_authors_conn.author_id = authors.author_id) ON books_authors_conn.ISBN_id = book.ISBN_id) ON book.ISBN_id = inventory.ISBN_id) ON booking.book_id = inventory.book_id WHERE booking.user_id = ID GROUP BY booking.booking_id ORDER BY booking.booking_id DESC)
UNION ALL
(SELECT book.title, GROUP_CONCAT(DISTINCT authors.author), 'reservation', book.ISBN, reservation.reservation_id, "" FROM reservation INNER JOIN (inventory INNER JOIN (book INNER JOIN (books_authors_conn INNER JOIN authors ON books_authors_conn.author_id = authors.author_id) ON books_authors_conn.ISBN_id = book.ISBN_id) ON inventory.ISBN_id = book.ISBN_id)ON reservation.ISBN_id = inventory.ISBN_id WHERE reservation.user_id = ID GROUP BY reservation.reservation_id ORDER BY reservation.reservation_id DESC);
END;//
DELIMITER ;

-- cancel reservation by id and userid check
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS cancelReservation(
  IN RESID INT,
  IN USID INT
) BEGIN
DELETE FROM reservation WHERE reservation.reservation_id = RESID AND reservation.user_id = USID;
END;//
DELIMITER ;

-- cancel booking by id and userid check
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS cancelBooking(
  IN BOOKID INT,
  IN USID INT
) BEGIN
DECLARE IDBook INT DEFAULT 0;
SET IDBook = (SELECT booking.book_id FROM booking WHERE booking.booking_id = BOOKID);
DELETE FROM booking WHERE booking.booking_id = BOOKID AND booking.user_id = USID;
IF ((SELECT COUNT(reservation.reservation_id) FROM reservation WHERE reservation.ISBN_id = (SELECT inventory.ISBN_id FROM inventory WHERE inventory.book_id = IDBook AND inventory.available))>0) THEN
-- out of sync error occur when calling this maybe we need to add it manually
-- CALL addReservationOrBooking((SELECT inventory.ISBN_id FROM inventory WHERE inventory.book_id = IDBook), (SELECT reservation.user_id FROM reservation WHERE reservation.ISBN_id = (SELECT inventory.ISBN_id FROM inventory WHERE inventory.book_id = IDBook) ORDER BY reservation.reservation_id ASC LIMIT 1));
-- adding manually 
INSERT INTO booking(booking.book_id, booking.user_id, booking.end_date) VALUES(IDBook, (SELECT reservation.user_id FROM reservation WHERE reservation.ISBN_id = (SELECT inventory.ISBN_id FROM inventory WHERE inventory.book_id = IDBook) ORDER BY reservation.reservation_id ASC LIMIT 1), CURRENT_DATE()+INTERVAL (SELECT system_settings.reservation_time FROM system_settings) DAY);
-- delete the shifted reservation
DELETE FROM reservation WHERE reservation.reservation_id = (SELECT reservation.reservation_id FROM reservation WHERE reservation.ISBN_id = (SELECT inventory.ISBN_id FROM inventory WHERE inventory.book_id = IDBook) ORDER BY reservation.reservation_id ASC LIMIT 1);
-- notify which user is now booked
SELECT booking.user_id FROM booking WHERE booking.book_id = IDBook;
END IF;
END;//
DELIMITER ;

-- get all borrowed books borrowed by userID
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getBorrowedBooks(
  IN ID INT
) BEGIN
SELECT 
  inventory.book_id, GROUP_CONCAT(DISTINCT authors.author) AS `authors`,  book.ISBN, book.title, book.picture_base64, borrowings.end_date, borrowings.start_date, ( SELECT CASE WHEN COUNT(reservation.ISBN_id) > 0 THEN 'True' ELSE 'False' END FROM reservation WHERE reservation.ISBN_id = inventory.ISBN_id ) AS `meghosszabbithato`, (CASE WHEN (CURRENT_DATE()- borrowings.end_date)*(SELECT system_settings.latency_fee FROM system_settings)<0 THEN 0 ELSE (CURRENT_DATE()- borrowings.end_date)*(SELECT system_settings.latency_fee FROM system_settings)END) AS `fizetendo`
FROM 
  users INNER JOIN( borrowings INNER JOIN( ((inventory INNER JOIN book ON book.ISBN_id = inventory.ISBN_id) INNER JOIN books_authors_conn on books_authors_conn.ISBN_id = book.ISBN_id) INNER JOIN authors on authors.author_id = books_authors_conn.author_id ) ON inventory.book_id = borrowings.book_id ) ON users.user_id = borrowings.user_id 
WHERE 
  users.user_id = ID AND borrowings.returned = 0 
GROUP BY borrowings.borrowing_id ORDER BY borrowings.start_date DESC;
END;//
DELIMITER ;

-- returns books that were previously borrowed by the given user
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getPreviouslyBorrowedBooks(
  IN ID INT
) BEGIN
SELECT 
  inventory.book_id, GROUP_CONCAT(DISTINCT authors.author) AS `authors`,  book.ISBN, book.title, book.picture_base64, borrowings.end_date, borrowings.start_date
FROM 
  users INNER JOIN( borrowings INNER JOIN( ((inventory INNER JOIN book ON book.ISBN_id = inventory.ISBN_id) INNER JOIN books_authors_conn on books_authors_conn.ISBN_id = book.ISBN_id) INNER JOIN authors on authors.author_id = books_authors_conn.author_id ) ON inventory.book_id = borrowings.book_id ) ON users.user_id = borrowings.user_id 
WHERE 
  users.user_id = ID AND borrowings.returned = 1
GROUP BY borrowings.borrowing_id;
END;//
DELIMITER ;

-- automatically deletes bookings that are not picked up or users membership expired and notifies next (kinézet: egy concated string ami [bookid], [deletedUserid], [newUserid -1 ha nincs ilyen könyvre igény], [expmember-ha a membership expired, notpicked-ha nem vették át];[next row of things])
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS deleteLateBookings()
BEGIN
DECLARE output VARCHAR(255) DEFAULT "";
-- delete lates
FOR bookID IN (SELECT booking.book_id, IF(users.membership_end_date<CURRENT_DATE(), 'expmember', 'notpicked') AS 'status' FROM booking INNER JOIN users ON users.user_id  = booking.user_id WHERE booking.end_date<CURRENT_DATE() OR users.membership_end_date<CURRENT_DATE())
DO
SET output = CONCAT(output, bookID.book_id, ',', (SELECT booking.user_id FROM booking WHERE booking.book_id = bookID.book_id));
DELETE FROM booking WHERE booking.book_id = bookID.book_id;
IF ((SELECT COUNT(reservation.reservation_id) FROM reservation WHERE reservation.ISBN_id = (SELECT inventory.ISBN_id FROM inventory WHERE inventory.book_id = bookID.book_id AND inventory.available))>0) THEN
-- insert if there is reservation for the book
INSERT INTO booking(booking.book_id, booking.user_id, booking.end_date) VALUES(bookID.book_id, (SELECT reservation.user_id FROM reservation WHERE reservation.ISBN_id = (SELECT inventory.ISBN_id FROM inventory WHERE inventory.book_id = bookID.book_id) ORDER BY reservation.reservation_id ASC LIMIT 1), CURRENT_DATE()+INTERVAL (SELECT system_settings.reservation_time FROM system_settings) DAY);
-- delete the shifted reservation
DELETE FROM reservation WHERE reservation.reservation_id = (SELECT reservation.reservation_id FROM reservation WHERE reservation.ISBN_id = (SELECT inventory.ISBN_id FROM inventory WHERE inventory.book_id = bookID.book_id) ORDER BY reservation.reservation_id ASC LIMIT 1);
-- notify which user is now booked
SET output = CONCAT(output, ',', (SELECT booking.user_id FROM booking WHERE booking.book_id = bookID.book_id));
ELSE
SET output = CONCAT(output, ',', '-1');
END IF;
SET output = CONCAT(output, ',', bookID.status, ';');
END FOR;
SELECT output;
END;//
DELIMITER ;

-- automatically deletes reservations where users membership expired and notifies next (kinézet: egy concated string ami [ISBN], [deletedUserid];[next row of things])
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS deleteLateReservations()
BEGIN
DECLARE output VARCHAR(255) DEFAULT "";
-- delete late reservations
FOR resID IN (SELECT reservation.reservation_id FROM reservation INNER JOIN users ON users.user_id = reservation.user_id WHERE users.membership_end_date<CURRENT_DATE())
DO
SET output = CONCAT(output, (SELECT reservation.ISBN_id FROM reservation WHERE reservation.reservation_id = resID.reservation_id), ',', (SELECT reservation.user_id FROM reservation WHERE reservation.reservation_id = resID.reservation_id), ';');
DELETE FROM reservation WHERE reservation.reservation_id = resID.reservation_id;
END FOR;
SELECT output;
END;//
DELIMITER ;

-- logs in user
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS loginUser(
  IN username VARCHAR(255),
  IN pw VARCHAR(255)
) BEGIN
IF((SELECT COUNT(users.user_id) FROM users WHERE users.username = username)=0) THEN
  SELECT 'not found' AS result;
ELSEIF((SELECT COUNT(users.user_id) FROM users WHERE users.username = username AND users.password IS NULL AND users.active) = 1) THEN
  SELECT 'not registered' AS result;
ELSE
  SELECT CASE WHEN (users.active) THEN CASE WHEN (users.password = PASSWORD(pw)) THEN 'true' ELSE 'false' END END AS 'result', CASE WHEN users.membership_end_date<CURRENT_DATE() THEN 'false' ELSE 'true' END AS 'member', user_id FROM users WHERE users.username = username;
END IF;
END;//
DELIMITER ;

-- for login get userid so we can set session
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getUserId(
  IN username VARCHAR(255)
) BEGIN
SELECT users.user_id FROM users WHERE users.username = username;
END;//
DELIMITER ;

-- get email by user id
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getEmailData(
  IN ID INT
) BEGIN
SELECT users.email, users.surname, users.first_name FROM users WHERE users.user_id = ID;
END;//
DELIMITER ;

-- update user details
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS updateUserDetails(
  IN userID INT,
  IN surname VARCHAR(255),
  IN first_name VARCHAR(255),
  IN birth_place VARCHAR(255),
  IN birth_date DATE,
  IN address VARCHAR(255),
  IN email VARCHAR(255),
  IN phone_num VARCHAR(255),
  IN mmn VARCHAR(255)
) BEGIN
UPDATE users SET users.surname = surname, users.first_name = first_name, users.birth_place = birth_place, users.birth_date = birth_date, users.address = address, users.email = email, users.phone_number = phone_num, users.mother_maiden_name = mmn WHERE users.user_id = userID;
END;//
DELIMITER ;

-- update book data
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS updateBookDetails(
  IN ISBN_id INT,
  IN title VARCHAR(255),
  IN release_date DATE,
  IN lang VARCHAR(255),
  IN publisher VARCHAR(255),
  IN authors VARCHAR(255),
  IN genres VARCHAR(255),
  IN description TEXT,
  IN picture_base64 TEXT
) BEGIN
DECLARE _next TEXT DEFAULT NULL;
DECLARE _nextlen INT DEFAULT NULL;
DECLARE _value TEXT DEFAULT NULL;
-- check if that language exists
IF (SELECT languages.lang_id FROM languages WHERE languages.lang = lang) IS NULL THEN 
INSERT INTO languages(languages.lang) VALUES(lang);
END IF;
-- delete from conn table -> check if all authors exists in db -> if not make them and then insert to conn table too
DELETE FROM books_authors_conn WHERE books_authors_conn.ISBN_id = ISBN_id;
iterator1:
        LOOP
          -- exit the loop if the list seems empty or was null;
          -- this extra caution is necessary to avoid an endless loop in the proc.
          IF CHAR_LENGTH(TRIM(authors)) = 0 OR authors IS NULL THEN
            LEAVE iterator1;
          END IF;

          -- capture the next value from the list
          SET _next = SUBSTRING_INDEX(authors,',',1);

          -- save the length of the captured value; we will need to remove this
          -- many characters + 1 from the beginning of the string 
          -- before the next iteration
          SET _nextlen = CHAR_LENGTH(_next);

          -- trim the value of leading and trailing spaces, in case of sloppy CSV strings
          SET _value = TRIM(_next);

          -- insert the extracted value into the target table
          IF (SELECT COUNT(authors.author_id) FROM authors WHERE authors.author = _value) = 0 THEN
        	BEGIN
            	INSERT INTO authors(authors.author) VALUES(_value);
             END;
          END IF;
          INSERT INTO books_authors_conn(books_authors_conn.ISBN_id, books_authors_conn.author_id) VALUES(ISBN_id, (SELECT authors.author_id FROM authors WHERE authors.author = _value));

          -- rewrite the original string using the `INSERT()` string function,
          -- args are original string, start position, how many characters to remove, 
          -- and what to "insert" in their place (in this case, we "insert"
          -- an empty string, which removes _nextlen + 1 characters)
          SET authors = INSERT(authors,1,_nextlen + 1,'');
        END LOOP;
    DELETE FROM books_genres_conn WHERE books_genres_conn.ISBN_id = ISBN_id;
	-- sambe but for genres
	iterator2:
        LOOP
          -- exit the loop if the list seems empty or was null;
          -- this extra caution is necessary to avoid an endless loop in the proc.
          IF CHAR_LENGTH(TRIM(genres)) = 0 OR genres IS NULL THEN
            LEAVE iterator2;
          END IF;

          -- capture the next value from the list
          SET _next = SUBSTRING_INDEX(genres,',',1);

          -- save the length of the captured value; we will need to remove this
          -- many characters + 1 from the beginning of the string 
          -- before the next iteration
          SET _nextlen = CHAR_LENGTH(_next);

          -- trim the value of leading and trailing spaces, in case of sloppy CSV strings
          SET _value = TRIM(_next);

          -- insert the extracted value into the target table
          IF (SELECT COUNT(genres.genre_id) FROM genres WHERE genres.genre = _value) = 0 THEN
        	BEGIN
            	INSERT INTO genres(genres.genre) VALUES(_value);
             END;
          END IF;
		  INSERT INTO books_genres_conn(books_genres_conn.ISBN_id, books_genres_conn.genre_id) VALUES(ISBN_id, (SELECT genres.genre_id FROM genres WHERE genres.genre = _value));

          -- rewrite the original string using the `INSERT()` string function,
          -- args are original string, start position, how many characters to remove, 
          -- and what to "insert" in their place (in this case, we "insert"
          -- an empty string, which removes _nextlen + 1 characters)
          SET genres = INSERT(genres,1,_nextlen + 1,'');
        END LOOP;
  UPDATE book SET book.title = title, book.release_date = release_date, book.lang_id = (SELECT languages.lang_id FROM languages WHERE languages.lang = lang), book.publisher_id = (SELECT publishers.publisher_id FROM publishers WHERE publishers.name = publisher), book.description = description, book.picture_base64 = picture_base64 WHERE book.ISBN_id = ISBN_id;
  -- delete langs/authors/genres that are not in any of the books
  DELETE FROM languages WHERE languages.lang_id NOT IN (SELECT book.lang_id FROM book);
  DELETE FROM authors WHERE authors.author_id NOT IN (SELECT books_authors_conn.author_id FROM books_authors_conn);
  DELETE FROM genres WHERE genres.genre_id NOT IN (SELECT books_genres_conn.genre_id FROM books_genres_conn);
END;//
DELIMITER ;

-- gets user data
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getUser(
  IN userid INT
) BEGIN
SELECT users.surname, users.first_name, users.username, users.birth_date, users.birth_place, users.email, users.phone_number, users.address, users.mother_maiden_name, users.membership_end_date, users.active FROM users WHERE users.user_id = userid;
END;//
DELIMITER ;

-- gets employee data
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getEmployee(
  IN empl_id INT
) BEGIN
SELECT employees.empl_name, employees.empl_uname, employees.admin FROM employees WHERE employees.empl_id = empl_id;
END;//
DELIMITER ;

-- returns if the book can be reserved or booked
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS checkAvailability(
 ISBN INT,
 userid INT
) BEGIN
DECLARE status VARCHAR(11) DEFAULT "";
SET status = (SELECT CASE WHEN (SELECT COUNT(borrowings.book_id) FROM borrowings INNER JOIN inventory ON borrowings.book_id = inventory.book_id WHERE inventory.ISBN_id = ISBN AND inventory.available AND borrowings.returned = 0) +( SELECT COUNT(booking.book_id) FROM booking INNER JOIN inventory ON booking.book_id = inventory.book_id WHERE inventory.ISBN_id = ISBN ) >= (SELECT COUNT(inventory.book_id) FROM inventory WHERE inventory.ISBN_id = ISBN) THEN 'reservation' ELSE 'booking' END);
SELECT status, IF(status='reservation', CASE WHEN (SELECT COUNT(reservation.ISBN_id) FROM reservation INNER JOIN users ON reservation.user_id = users.user_id WHERE users.user_id = userid)<=3 AND (SELECT users.membership_end_date FROM users WHERE users.user_id = userid)>=CURRENT_DATE() THEN 'true' ELSE 'false' END, CASE WHEN (SELECT COUNT(booking.book_id) FROM booking INNER JOIN users ON booking.user_id = users.user_id WHERE users.user_id = userid)<=(SELECT system_settings.max_reservations FROM system_settings) AND (SELECT users.membership_end_date FROM users WHERE users.user_id = userid)>=CURRENT_DATE() THEN 'true' ELSE 'false' END) AS `available`;
END;//
DELIMITER;


-- reserves or books a book depending on avaliablity
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS addReservationOrBooking(
  ISBN INT,
  userid INT
) BEGIN
DECLARE _selected VARCHAR(20) DEFAULT '';
SET _selected = (SELECT CASE WHEN (SELECT COUNT(borrowings.book_id) FROM borrowings INNER JOIN inventory ON borrowings.book_id = inventory.book_id WHERE inventory.ISBN_id = ISBN AND inventory.available AND borrowings.returned = 0) +( SELECT COUNT(booking.book_id) FROM booking INNER JOIN inventory ON booking.book_id = inventory.book_id WHERE inventory.ISBN_id = ISBN ) >= (SELECT COUNT(inventory.book_id) FROM inventory WHERE inventory.ISBN_id = ISBN) THEN 'reservation' ELSE 'booking' END);
IF (_selected = 'booking') THEN 
BEGIN
  DECLARE _bookid INT DEFAULT '';
  SET _bookid = (SELECT inventory.book_id FROM inventory LEFT JOIN borrowings ON borrowings.book_id = inventory.book_id WHERE inventory.book_id NOT IN (SELECT borrowings.book_id FROM borrowings WHERE borrowings.returned = 0) AND inventory.book_id NOT IN (SELECT booking.book_id FROM booking) AND inventory.ISBN_id = ISBN AND inventory.available LIMIT 1);
	INSERT INTO booking(book_id, user_id, end_date) VALUES(_bookid, userid, CURRENT_DATE()+INTERVAL (SELECT system_settings.reservation_time FROM system_settings) DAY);
END;
ELSEIF (_selected = 'reservation') THEN 
  INSERT INTO reservation(ISBN_id, user_id) VALUES(ISBN, userid);
END IF;
SELECT _selected AS status;
END;//
DELIMITER ;


-- extends the return date
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS extendReturnDate(
  bookid INT,
  userid INT
) BEGIN
UPDATE borrowings SET borrowings.end_date = DATE_ADD(borrowings.end_date, INTERVAL (SELECT system_settings.lengthening_time FROM system_settings) DAY) WHERE borrowings.user_id = userid AND borrowings.book_id = bookid AND borrowings.returned = 0;
END;//
DELIMITER ;

-- check if return date can be extended
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS extendable(
  bookid INT,
  userid INT
) BEGIN
IF(((SELECT DATEDIFF(borrowings.end_date, borrowings.start_date) FROM borrowings WHERE borrowings.user_id = userid AND borrowings.book_id = bookid AND borrowings.returned = 0)<(SELECT system_settings.borrowing_time+system_settings.lengthening_time*system_settings.max_lengthenings FROM system_settings)) AND ((SELECT inventory.ISBN_id FROM inventory WHERE inventory.book_id = (SELECT borrowings.book_id FROM borrowings WHERE borrowings.user_id = userid AND borrowings.book_id = bookid AND borrowings.returned = 0)) NOT IN (SELECT reservation.ISBN_id FROM reservation))) THEN SELECT 'true'; ELSE SELECT 'false'; END IF;
END;//
DELIMITER ;

-- PROCEDURES FOR THE DESKTOP APP
-- Gets all books can be searched by book id and isbn
-- NOT TESTED NEED TO TEST IN APP
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getAllBooks(
  IN searchTerm VARCHAR(13),
  IN offseter INT,
  IN limiter INT
) BEGIN
SELECT book.ISBN, inventory.book_id, book.title FROM book INNER JOIN inventory ON inventory.ISBN_id = book.ISBN_id WHERE (inventory.book_id = searchTerm OR book.ISBN = searchTerm) OR searchTerm = '' LIMIT limiter OFFSET offseter;
END;//
DELIMITER ;


-- deletes expired tokens
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS deleteExpiredTokens() 
BEGIN
DELETE FROM tokens WHERE tokens.expiry_date < NOW();
END;//
DELIMITER ;

-- updates tokens
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS updateToken(
  IN user_id INT,
  IN newToken VARCHAR(11),
  IN oldToken VARCHAR(11),
  IN type VARCHAR(255)
) BEGIN

IF (type = "reset") THEN 
  UPDATE tokens SET tokens.token = newToken, tokens.expiry_date = (SELECT DATE_ADD(NOW(), INTERVAL (SELECT system_settings.reset_token_expiration FROM system_settings) HOUR)) WHERE tokens.type = type AND tokens.user_id  = user_id AND tokens.token = oldToken;
  SELECT "true" as result;
ELSEIF (type = "remember_me") THEN
  UPDATE tokens SET tokens.token = newToken, tokens.expiry_date = (SELECT DATE_ADD(NOW(), INTERVAL (SELECT system_settings.login_token_expiration FROM system_settings) DAY)) WHERE tokens.type = type AND tokens.user_id  = user_id AND tokens.token = oldToken;
  SELECT "true" as result;
ELSE
  SELECT "unhandled type given" as result;

END IF;

END;//
DELIMITER ;

-- generates token and deletes expired ones
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS generateToken(
  IN user_id INT,
  IN token VARCHAR(11),
  IN type VARCHAR(255)
) BEGIN
-- delete expired tokens
CALL deleteExpiredTokens();

IF((SELECT COUNT(tokens.token) FROM tokens WHERE tokens.token = token)=0)THEN

  IF(user_id = -1) THEN
    SELECT "false" AS result;

  ELSE
    IF (type = "reset") THEN 
      INSERT INTO tokens(tokens.token, tokens.user_id, tokens.type, tokens.expiry_date) VALUES(token, user_id, type, (SELECT DATE_ADD(NOW(), INTERVAL (SELECT system_settings.reset_token_expiration FROM system_settings) HOUR)));
    ELSEIF (type = "remember_me") THEN
      INSERT INTO tokens(tokens.token, tokens.user_id, tokens.type, tokens.expiry_date) VALUES(token, user_id, type, (SELECT DATE_ADD(NOW(), INTERVAL (SELECT system_settings.login_token_expiration FROM system_settings) DAY)));
    END IF;

    SELECT "true" as result;
  END IF;

ELSE

  IF(user_id = -1) THEN
    IF (type = "remember_me") THEN
      SELECT "loginFound" AS result, CASE WHEN users.membership_end_date<CURRENT_DATE() THEN "false" ELSE "true" END AS member, tokens.user_id FROM tokens INNER JOIN users ON tokens.user_id = users.user_id WHERE tokens.token = token; 
    ELSEIF(type = "reset") THEN
      SELECT "resetPossible" AS result, tokens.user_id FROM tokens where tokens.token = token;
    ELSE
      SELECT "unhandled type given" AS result;
    END IF;

  ELSE
    SELECT "false" as result;

  END IF;
END IF;
END;//
DELIMITER ;

-- changes password 
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS changePassword(
  IN password VARCHAR(255),
  IN user_id INT
) BEGIN
UPDATE users SET users.password = PASSWORD(password) WHERE users.user_id = user_id;
END;//
DELIMITER ;

-- changes employee password
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS changeEmplPass(
  IN empl_id INT,
  IN oldPass VARCHAR(255),
  IN newPass VARCHAR(255)
) BEGIN
IF(SELECT employees.password FROM employees WHERE employees.empl_id = empl_id) = (SELECT PASSWORD(oldPass))THEN
  UPDATE employees SET employees.password = PASSWORD(newPass);
  SELECT "siker" AS result;
ELSE
  SELECT "sikertelen" AS result;
END IF;
END;//
DELIMITER ;

-- deletes a token
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS deleteToken(
  IN token VARCHAR(11)
) BEGIN
DELETE FROM tokens WHERE tokens.token = token;
END;//
DELIMITER ;

-- Add a book type
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS addBookType(
  IN ISBN VARCHAR(13),
  IN title VARCHAR(255),
  IN allGenres VARCHAR(255),
  IN allAuthors VARCHAR(255),
  IN publisher VARCHAR(255),
  IN releaseDate DATE,
  IN lang VARCHAR(255),
  IN descript TEXT,
  IN picture TEXT
) BEGIN
DECLARE _next TEXT DEFAULT NULL;
DECLARE _nextlen INT DEFAULT NULL;
DECLARE _value TEXT DEFAULT NULL;
IF (SELECT COUNT(book.ISBN_id) FROM book WHERE book.ISBN = ISBN) = 0 THEN
	BEGIN
    	-- add book
        IF (SELECT COUNT(languages.lang_id) FROM languages WHERE languages.lang = lang) = 0 THEN
        	BEGIN
            	INSERT INTO languages(languages.lang) VALUES(lang);
             END;
        END IF;
        INSERT INTO book(book.ISBN, book.title, book.publisher_id, book.release_date, book.lang_id, book.description, book.picture_base64) VALUES(ISBN, title, (SELECT publishers.publisher_id FROM publishers WHERE publishers.name = publisher), releaseDate, (SELECT languages.lang_id FROM languages WHERE languages.lang = lang), descript, picture);
		
        -- ADD AUTHORS
        
        iterator1:
        LOOP
          -- exit the loop if the list seems empty or was null;
          -- this extra caution is necessary to avoid an endless loop in the proc.
          IF CHAR_LENGTH(TRIM(allAuthors)) = 0 OR allAuthors IS NULL THEN
            LEAVE iterator1;
          END IF;

          -- capture the next value from the list
          SET _next = SUBSTRING_INDEX(allAuthors,',',1);

          -- save the length of the captured value; we will need to remove this
          -- many characters + 1 from the beginning of the string 
          -- before the next iteration
          SET _nextlen = CHAR_LENGTH(_next);

          -- trim the value of leading and trailing spaces, in case of sloppy CSV strings
          SET _value = TRIM(_next);

          -- insert the extracted value into the target table
          IF (SELECT COUNT(authors.author_id) FROM authors WHERE authors.author = _value) = 0 THEN
        	BEGIN
            	INSERT INTO authors(authors.author) VALUES(_value);
             END;
          END IF;
          INSERT INTO books_authors_conn(books_authors_conn.ISBN_id, books_authors_conn.author_id) VALUES((SELECT book.ISBN_id FROM book WHERE book.ISBN = ISBN), (SELECT authors.author_id FROM authors WHERE authors.author = _value));

          -- rewrite the original string using the `INSERT()` string function,
          -- args are original string, start position, how many characters to remove, 
          -- and what to "insert" in their place (in this case, we "insert"
          -- an empty string, which removes _nextlen + 1 characters)
          SET allAuthors = INSERT(allAuthors,1,_nextlen + 1,'');
        END LOOP;
        
        -- ADD CATHEGORIES
        
        iterator2:
        LOOP
          -- exit the loop if the list seems empty or was null;
          -- this extra caution is necessary to avoid an endless loop in the proc.
          IF CHAR_LENGTH(TRIM(allGenres)) = 0 OR allGenres IS NULL THEN
            LEAVE iterator2;
          END IF;

          -- capture the next value from the list
          SET _next = SUBSTRING_INDEX(allGenres,',',1);

          -- save the length of the captured value; we will need to remove this
          -- many characters + 1 from the beginning of the string 
          -- before the next iteration
          SET _nextlen = CHAR_LENGTH(_next);

          -- trim the value of leading and trailing spaces, in case of sloppy CSV strings
          SET _value = TRIM(_next);

          -- insert the extracted value into the target table
          IF (SELECT COUNT(genres.genre_id) FROM genres WHERE genres.genre = _value) = 0 THEN
        	BEGIN
            	INSERT INTO genres(genres.genre) VALUES(_value);
             END;
          END IF;
		  INSERT INTO books_genres_conn(books_genres_conn.ISBN_id, books_genres_conn.genre_id) VALUES((SELECT book.ISBN_id FROM book WHERE book.ISBN = ISBN), (SELECT genres.genre_id FROM genres WHERE genres.genre = _value));
          -- rewrite the original string using the `INSERT()` string function,
          -- args are original string, start position, how many characters to remove, 
          -- and what to "insert" in their place (in this case, we "insert"
          -- an empty string, which removes _nextlen + 1 characters)
          SET allGenres = INSERT(allGenres,1,_nextlen + 1,'');
        END LOOP;
    END;
    SELECT book.ISBN_id AS state FROM book WHERE book.ISBN = ISBN;
ELSE
	SELECT 'Already exists' AS state;
END IF;
END;//
DELIMITER ;

-- Add a book
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS addBook(
  IN ISBN VARCHAR(13)
) BEGIN
INSERT INTO inventory(inventory.ISBN_id, inventory.available) VALUES((SELECT book.ISBN_id FROM book WHERE book.ISBN = ISBN), 1);
END;//
DELIMITER ;

-- for desktop login
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS loginEmployee(
  IN username VARCHAR(255), 
  IN pw VARCHAR(255)
) BEGIN
SELECT CASE WHEN employees.password = PASSWORD(pw) AND employees.active THEN employees.empl_id ELSE 'false' END AS 'info' FROM employees WHERE employees.empl_uname = username;
END;//
DELIMITER ;

-- gets all users for database
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getUsers(
IN searchTerm VARCHAR(255)
)
BEGIN
IF(searchTerm = "") THEN
SELECT users.user_id, users.surname, users.first_name, users.username FROM users WHERE users.active;
ELSE
SELECT users.user_id,users.surname, users.first_name, users.username FROM users WHERE users.surname LIKE CONCAT("%", searchTerm, "%") OR users.first_name LIKE CONCAT("%", searchTerm, "%") OR users.username LIKE CONCAT("%", searchTerm, "%") AND users.active; 
END IF;
END;//
DELIMITER ;

-- gets all active employees
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getEmployees(
) BEGIN
SELECT employees.empl_id, employees.empl_name, employees.empl_uname FROM employees WHERE employees.active;
END;//
DELIMITER ;

-- gets all books with search term for database
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getBooks(
IN searchTerm VARCHAR(255)
)
BEGIN
IF(searchTerm = "") THEN
SELECT inventory.book_id, book.ISBN, book.title, inventory.available, IF(j.borrowing_id IS NULL, IF(k.booking_id IS NULL, "available", "booked"),"borrowed") AS "status" FROM ((inventory LEFT JOIN (SELECT booking.booking_id, booking.book_id FROM booking) k ON k.book_id = inventory.book_id) LEFT JOIN (SELECT borrowings.borrowing_id, borrowings.book_id FROM borrowings WHERE borrowings.returned = 0 GROUP BY borrowings.book_id) j ON inventory.book_id = j.book_id) INNER JOIN book ON book.ISBN_id = inventory.ISBN_id WHERE inventory.available OR (NOT inventory.available AND j.book_id IS NOT NULL);
ELSE
SELECT inventory.book_id, book.ISBN, book.title, inventory.available, IF(j.borrowing_id IS NULL, IF(k.booking_id IS NULL, "available", "booked"),"borrowed") AS "status" FROM ((inventory LEFT JOIN (SELECT booking.booking_id, booking.book_id FROM booking) k ON k.book_id = inventory.book_id) LEFT JOIN (SELECT borrowings.borrowing_id, borrowings.book_id FROM borrowings WHERE borrowings.returned = 0 GROUP BY borrowings.book_id) j ON inventory.book_id = j.book_id) INNER JOIN book ON book.ISBN_id = inventory.ISBN_id WHERE (inventory.available OR (NOT inventory.available AND j.book_id IS NOT NULL)) AND inventory.ISBN_id LIKE CONCAT("%", searchTerm, "%") OR book.title LIKE CONCAT("%", searchTerm, "%"); 
END IF;
END;//
DELIMITER ;

-- gets all publishers with search term
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getPublishers(
IN searchTerm VARCHAR(255)
)
BEGIN
IF(searchTerm = "") THEN
SELECT * FROM publishers;
ELSE
SELECT * FROM publishers WHERE publishers.name LIKE CONCAT("%", searchTerm, "%") OR publishers.phone LIKE CONCAT("%", searchTerm, "%") OR publishers.email LIKE CONCAT("%", searchTerm, "%") OR publishers.webpage LIKE CONCAT("%", searchTerm, "%"); 
END IF;
END;//
DELIMITER ;

-- updates 1 line in publishers table
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS updatePublishers(
  IN id INT,
  IN pub_name VARCHAR(255),
  IN pub_phone VARCHAR(255),
  IN pub_email VARCHAR(255),
  IN pub_webpage VARCHAR(255)
)
BEGIN
UPDATE publishers SET publishers.name = pub_name, publishers.phone = pub_phone, publishers.email = pub_email, publishers.webpage = pub_webpage WHERE publishers.publisher_id = id;
END;//
DELIMITER ;

-- deletes a publisher (whole row)
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS deletePublisher(
 IN id INT 
)
BEGIN
IF((SELECT COUNT(book.ISBN_id) FROM book WHERE book.publisher_id = id) = 0) THEN 
  DELETE FROM publishers WHERE publishers.publisher_id = id;
  SELECT "success" AS "state";
ELSE
  SELECT "fail" AS "state";
END IF;
END;//
DELIMITER ;

-- get info for borrowing page
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS borrowInfo(
  IN id INT,
  IN state VARCHAR(255)
) BEGIN
IF (state = "booking") THEN 
	SELECT book.title, book.ISBN, CONCAT(users.first_name, users.surname) AS 'name', users.username, users.user_id FROM book INNER JOIN (inventory INNER JOIN (booking INNER JOIN users ON users.user_id = booking.user_id) ON inventory.book_id = booking.book_id) ON book.ISBN_id = inventory.ISBN_id WHERE booking.book_id = id;
ELSEIF (state = "book_id") THEN
	SELECT book.title, book.ISBN FROM book INNER JOIN inventory ON inventory.ISBN_id = book.ISBN_id WHERE inventory.book_id = id;
ELSE
SELECT CONCAT(users.surname, " ", users.first_name) AS "name", users.username FROM users WHERE users.user_id = id;
END IF;
END;//
DELIMITER ;

-- Borrow a book
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS borrowBook(
  IN userID INT,
  IN bookID INT,
  IN emplID INT
) BEGIN
IF (bookID IN (SELECT booking.book_id FROM booking) AND (userID NOT IN (SELECT booking.user_id FROM booking WHERE booking.book_id = bookID))) THEN  
SELECT 'Már valaki lefoglalta ezt a könyvet' AS state;
ELSE
-- add an active borrowing
INSERT INTO borrowings(borrowings.book_id, borrowings.user_id, borrowings.empl_e, borrowings.start_date, borrowings.end_date, borrowings.returned) VALUES(bookID, userID, emplID, CURRENT_DATE(), (SELECT CURRENT_DATE()+ INTERVAL (SELECT system_settings.borrowing_time FROM system_settings) DAY), 0);
IF (bookID IN (SELECT booking.book_id FROM booking) AND (userID IN (SELECT booking.user_id FROM booking WHERE booking.book_id = bookID))) THEN 
DELETE FROM booking WHERE booking.book_id = bookID;
END IF;
SELECT "siker" AS state;
END IF;
END;//
DELIMITER ;

-- Return a book
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS returnBook(
  IN userID INT,
  IN bookID INT,
  IN emplID INT
) BEGIN
-- check if it is late
-- modifying so it works with the notification 
DECLARE late INT DEFAULT 0;
IF (SELECT borrowings.end_date FROM borrowings WHERE borrowings.user_id = userID AND borrowings.book_id = bookID AND borrowings.returned = 0)-CURRENT_DATE()<0 THEN
SET late = (SELECT (CURRENT_DATE()-(SELECT borrowings.end_date FROM borrowings WHERE borrowings.user_id = userID AND borrowings.book_id = bookID AND borrowings.returned = 0))*(SELECT system_settings.latency_fee FROM system_settings));
END IF;
-- update borrowings
UPDATE borrowings SET borrowings.returned = 1, borrowings.empl_e = emplID, borrowings.end_date = CURRENT_DATE() WHERE borrowings.user_id = userID AND borrowings.book_id = bookID AND borrowings.returned = 0;
-- add next reservation to booking if exists
IF ((SELECT COUNT(reservation.reservation_id) FROM reservation WHERE reservation.ISBN_id = (SELECT inventory.ISBN_id FROM inventory WHERE inventory.book_id = bookID AND inventory.available))>0) THEN
-- out of sync error occur when calling this maybe we need to add it manually
-- CALL addReservationOrBooking((SELECT inventory.ISBN_id FROM inventory WHERE inventory.book_id = bookID), (SELECT reservation.user_id FROM reservation WHERE reservation.ISBN_id = (SELECT inventory.ISBN_id FROM inventory WHERE inventory.book_id = bookID) ORDER BY reservation.reservation_id ASC LIMIT 1));
-- adding manually 
INSERT INTO booking(booking.book_id, booking.user_id, booking.end_date) VALUES(bookID, (SELECT reservation.user_id FROM reservation WHERE reservation.ISBN_id = (SELECT inventory.ISBN_id FROM inventory WHERE inventory.book_id = bookID) ORDER BY reservation.reservation_id ASC LIMIT 1), CURRENT_DATE()+INTERVAL (SELECT system_settings.reservation_time FROM system_settings) DAY);
-- delete the shifted reservation
DELETE FROM reservation WHERE reservation.reservation_id = (SELECT reservation.reservation_id FROM reservation WHERE reservation.ISBN_id = (SELECT inventory.ISBN_id FROM inventory WHERE inventory.book_id = bookID) ORDER BY reservation.reservation_id ASC LIMIT 1);
SELECT booking.user_id AS 'new' FROM booking WHERE booking.book_id = bookID;
ELSE
-- will return -1 if nobody is in the reservation 
SELECT -1 AS 'new';
END IF;
END;//
DELIMITER ;

-- gets return info
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS returnInfo(
  IN bookID INT
) BEGIN
IF ((SELECT borrowings.end_date FROM borrowings WHERE borrowings.book_id = bookID AND borrowings.returned = 0)<CURRENT_DATE()) THEN
SELECT book.title AS 'title', book.ISBN AS 'ISBN', CONCAT(users.first_name, " ", users.surname) AS 'name', users.user_id AS 'user', borrowings.end_date AS 'end', DATEDIFF(CURRENT_DATE(), borrowings.end_date) AS 'late', (DATEDIFF(CURRENT_DATE(), borrowings.end_date)*(SELECT system_settings.latency_fee FROM system_settings)) AS 'fee' FROM users INNER JOIN (borrowings INNER JOIN (inventory INNER JOIN book ON book.ISBN_id = inventory.ISBN_id) ON borrowings.book_id = inventory.book_id) ON users.user_id = borrowings.user_id WHERE borrowings.book_id = bookID AND borrowings.returned = 0; ELSE
SELECT book.title AS 'title', book.ISBN AS 'ISBN', CONCAT(users.first_name, " ", users.surname) AS 'name', users.user_id AS 'user', borrowings.end_date AS 'end' FROM users INNER JOIN (borrowings INNER JOIN (inventory INNER JOIN book ON book.ISBN_id = inventory.ISBN_id) ON borrowings.book_id = inventory.book_id) ON users.user_id = borrowings.user_id WHERE borrowings.book_id = bookID AND borrowings.returned = 0;
END IF;
END;//
DELIMITER ;

-- adds a publisher
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS addPublisher(
  IN pubname VARCHAR(255),
  IN phone VARCHAR(255),
  IN email VARCHAR(255),
  IN webpage VARCHAR(255)
) BEGIN
IF ((SELECT publishers.name FROM publishers WHERE publishers.name = pubname) IS NULL) THEN 
	INSERT INTO publishers(publishers.name, publishers.phone, publishers.email, publishers.webpage) VALUES(pubname, phone, email, webpage); 
  SELECT "success" AS state;
ELSE 
	SELECT "fail" AS state; 
END IF; 
END;//
DELIMITER ;

-- adds a user
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS addUser(
  IN surname VARCHAR(255), 
  IN firstname VARCHAR(255), 
  IN uname VARCHAR(255),
  IN birthdate DATE, 
  IN email VARCHAR(255),
  IN phone VARCHAR(255),
  IN birthplace VARCHAR(255), 
  IN address VARCHAR(255),
  IN mmn VARCHAR(255) 
) BEGIN
IF ((SELECT users.user_id FROM users WHERE users.surname = surname AND users.first_name = firstname AND users.birth_date = birthdate AND users.birth_place = birthplace AND users.mother_maiden_name  = mmn) IS NULL) THEN 
	INSERT INTO users(users.surname, users.first_name, users.username, users.birth_date, users.membership_end_date, users.email, users.phone_number, users.birth_place, users.address, users.mother_maiden_name, users.active) VALUES(surname, firstname, uname ,birthdate, (SELECT CURRENT_DATE() - INTERVAL 1 DAY), email, phone, birthplace, address, mmn, 1);
  SELECT "Siker" AS state;
ELSE 
	SELECT "A személy már egyszer beregisztrált" AS state; 
END IF; 
END;//
DELIMITER ;

-- adds an employee
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS addEmployee(
  IN name VARCHAR(255),
  IN uname VARCHAR(255),
  IN pw VARCHAR(255)
) BEGIN
  INSERT INTO employees(employees.empl_name, employees.empl_uname, employees.password, employees.active, employees.admin) VALUES(name, uname, PASSWORD(pw), '1', '0');
END;//
DELIMITER ;

-- renew membership (member for a year)
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS renewMembership(
  IN user_id INT
) BEGIN
IF((SELECT users.membership_end_date FROM users WHERE users.user_id = user_id)<CURRENT_DATE()) THEN
	UPDATE users SET users.membership_end_date = CURRENT_DATE() + INTERVAL 1 YEAR WHERE users.user_id = user_id;
ELSE
	UPDATE users SET users.membership_end_date = DATE_ADD(users.membership_end_date, INTERVAL 1 YEAR) WHERE users.user_id = user_id;
END IF;
SELECT users.membership_end_date FROM users WHERE users.user_id = user_id;
END;//
DELIMITER ;

-- gets system settings for desktop
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getSystemSettings() 
BEGIN
SELECT * FROM system_settings;
END;//
DELIMITER ;

-- deactivates a user and deletes his/her bookings and reservation
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS deactivateUser(
  IN ID INT
) 
BEGIN
UPDATE users SET users.active = 0, users.membership_end_date = DATE_ADD(CURRENT_DATE(), INTERVAL -1 DAY) WHERE users.user_id = ID;
END;//
DELIMITER ;

-- deactivates an employee
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS deactivateEmpl(
  IN empl_id INT
) 
BEGIN
  UPDATE employees SET employees.active = 0 WHERE employees.empl_id = empl_id;
END;//
DELIMITER ;

-- checks if a user can book or reserve
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS checkPermissions(
  IN ID INT
) 
BEGIN
SELECT CASE WHEN (SELECT COUNT(reservation.reservation_id) FROM reservation WHERE reservation.user_id = ID)=(SELECT system_settings.max_reservations FROM system_settings) THEN "false" ELSE "true" END AS 'reservation',  CASE WHEN (SELECT COUNT(booking.booking_id) FROM booking WHERE booking.user_id = ID)>=(SELECT system_settings.max_reservations FROM system_settings) THEN "false" ELSE "true" END AS 'booking';
END;//
DELIMITER ;

-- gets state of books types with search
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getBookStates(
  IN search VARCHAR(255)
) 
BEGIN
-- túl büszke vagyok erre a lekérdezésre nem fogom eltűntetni
-- SELECT CASE WHEN (COUNT(DISTINCT inventory.book_id) > COUNT(j.booking_id)+COUNT(i.borrowing_id)) THEN k.book_id ELSE inventory.ISBN_id END AS id, book.ISBN, book.title, CASE WHEN (COUNT(DISTINCT inventory.book_id) > COUNT(j.booking_id)+COUNT(i.borrowing_id)) THEN "booking" ELSE "reservation" END AS state FROM (((book INNER JOIN inventory ON inventory.ISBN_id = book.ISBN_id) LEFT JOIN (SELECT booking.booking_id, booking.book_id FROM booking) j ON j.book_id = inventory.book_id) LEFT JOIN (SELECT borrowings.borrowing_id, borrowings.book_id FROM borrowings WHERE NOT borrowings.returned) i ON i.book_id = inventory.book_id) LEFT JOIN (SELECT inventory.book_id FROM inventory WHERE inventory.book_id NOT IN (SELECT borrowings.book_id FROM borrowings WHERE NOT borrowings.returned) AND inventory.book_id NOT IN (SELECT booking.book_id FROM booking)) k ON k.book_id = inventory.book_id WHERE (book.title LIKE CONCAT("%",search,"%") OR book.ISBN LIKE CONCAT("%",search,"%")) GROUP BY inventory.ISBN_id;
SELECT inventory.ISBN_id AS id, book.ISBN, book.title, CASE WHEN (COUNT(DISTINCT inventory.book_id) > COUNT(j.booking_id)+COUNT(i.borrowing_id)) THEN "booking" ELSE "reservation" END AS state FROM (((book INNER JOIN inventory ON inventory.ISBN_id = book.ISBN_id) LEFT JOIN (SELECT booking.booking_id, booking.book_id FROM booking) j ON j.book_id = inventory.book_id) LEFT JOIN (SELECT borrowings.borrowing_id, borrowings.book_id FROM borrowings WHERE NOT borrowings.returned) i ON i.book_id = inventory.book_id) WHERE (book.title LIKE CONCAT("%",search,"%") OR book.ISBN LIKE CONCAT("%",search,"%")) GROUP BY inventory.ISBN_id;
END;//
DELIMITER ;

-- gets all usernames that starts with the sent one for username generation
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getUsernames(
  IN name VARCHAR(255)
) 
BEGIN
  SELECT users.username FROM users WHERE users.username LIKE CONCAT(name, "%");
END;//
DELIMITER ;

-- gets all employee usernames that starts with the sent one for employee username generation
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getEmplUsernames(
  IN name VARCHAR(255)
) 
BEGIN
  SELECT employees.empl_uname FROM employees WHERE employees.empl_uname LIKE CONCAT(name, "%");
END;//
DELIMITER ;

-- gets all usernames that starts with the sent one for username generation
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getHistory(
  IN bookID INT,
  IN userID INT
) 
BEGIN
  SELECT CASE WHEN (SELECT COUNT(borrowings.borrowing_id) FROM borrowings INNER JOIN inventory ON inventory.book_id = borrowings.book_id WHERE inventory.ISBN_id = (SELECT inventory.ISBN_id FROM inventory WHERE inventory.book_id = bookID) AND borrowings.user_id = userID AND borrowings.returned) = 0 THEN "not" ELSE (SELECT DATEDIFF(start_date, CURRENT_DATE()) as Days FROM borrowings INNER JOIN inventory ON inventory.book_id = borrowings.book_id WHERE inventory.ISBN_id = (SELECT inventory.ISBN_id FROM inventory WHERE inventory.book_id = bookID ORDER BY 1 DESC LIMIT 1) AND borrowings.user_id = userID AND borrowings.returned) END AS result;
END;//
DELIMITER ;

-- gets all authors that is connected to an ISBN or its inverse
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getAuthors(
  IN ISBN_id INT,
  IN inverse BOOLEAN
) 
BEGIN
  IF NOT inverse THEN
    SELECT DISTINCT authors.author_id, authors.author FROM authors INNER JOIN books_authors_conn ON books_authors_conn.author_id = authors.author_id WHERE books_authors_conn.ISBN_id = ISBN_id; 
  ELSE
    SELECT DISTINCT authors.author_id, authors.author FROM authors INNER JOIN books_authors_conn ON books_authors_conn.author_id = authors.author_id; 
  END IF;
END;//
DELIMITER ;

-- gets all genres that is connected to an ISBN or its inverse
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getCategories(
  IN ISBN_id INT,
  IN inverse BOOLEAN
) 
BEGIN
  IF NOT inverse THEN
    SELECT DISTINCT genres.genre_id, genres.genre FROM genres INNER JOIN books_genres_conn ON books_genres_conn.genre_id = genres.genre_id WHERE books_genres_conn.ISBN_id = ISBN_id; 
  ELSE
    SELECT DISTINCT genres.genre_id, genres.genre FROM genres INNER JOIN books_genres_conn ON books_genres_conn.genre_id = genres.genre_id ; 
  END IF;
END;//
DELIMITER ;

-- deactivates a book
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS deactivateBook(
  IN book_id INT
) 
BEGIN
  UPDATE inventory SET inventory.available = 0 WHERE inventory.book_id = book_id;
END;//
DELIMITER;

-- inserts a book to invetnory
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS addToInventory(
  IN ISBN_id INT
) 
BEGIN
  INSERT INTO inventory(inventory.ISBN_id, inventory.available) VALUES(ISBN_id, 1);
  SELECT LAST_INSERT_ID() AS book_id;
END;//
DELIMITER ;
