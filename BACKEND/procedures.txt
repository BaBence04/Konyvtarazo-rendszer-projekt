-- procedure that lists books with filters applied
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS listBooksFiltered(
  IN title VARCHAR(255),
  IN genre VARCHAR(255),
  IN author VARCHAR(255),
  IN release_date VARCHAR(255),
  IN var_languages VARCHAR (255),
  IN var_ISBN VARCHAR(13),
  IN offseter INT,
  IN limiter INT
) BEGIN
CALL getBookById((SELECT
  GROUP_CONCAT(DISTINCT book.ISBN_id)
FROM
  book
  INNER JOIN (
    books_genres_conn
    INNER JOIN genres ON genres.genre_id = books_genres_conn.genre_id
  ) ON book.ISBN_id = books_genres_conn.ISBN_id
  INNER JOIN (
    books_authors_conn
    INNER JOIN authors ON authors.author_id = books_authors_conn.author_id
  ) ON book.ISBN_id = books_authors_conn.ISBN_id
  INNER JOIN publishers ON publishers.publisher_id = book.publisher_id
  INNER JOIN languages ON languages.lang_id = book.lang_id
  INNER JOIN inventory ON inventory.ISBN_id = book.ISBN_id
WHERE
  book.title LIKE CONCAT("%", title, "%")
  AND genres.genre LIKE CONCAT("%", genre, "%")
  AND authors.author LIKE CONCAT("%", author, "%")
  AND CAST(book.release_date AS VARCHAR(255)) LIKE CONCAT("%", release_date, "%")
  AND languages.lang LIKE CONCAT("%", var_languages, "%")
  AND book.ISBN LIKE CONCAT("%", var_ISBN, "%")
  AND inventory.available = TRUE
LIMIT limiter OFFSET offseter
));
END;//
DELIMITER ;

-- get book by isbn
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getBookByISBN(
  IN ISBN VARCHAR(255)
) BEGIN
	CALL getBookById((SELECT book.ISBN_id FROM book WHERE book.ISBN = ISBN LIMIT 1));
END;//
DELIMITER ;

-- gets all genres
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getGenres(
) BEGIN
	SELECT genres.genre FROM genres;
END;//
DELIMITER ;

-- gets all genres
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getLangs(
) BEGIN
	SELECT languages.lang FROM languages;
END;//
DELIMITER ;

-- converts isbn to isbnid
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getIdFromISBN(
  IN ISBN VARCHAR(255)
) BEGIN
	SELECT book.ISBN_id FROM book WHERE book.ISBN = ISBN LIMIT 1;
END;//
DELIMITER ;

-- procedure, that gets every information abt a book by id
-- can be used for desktop app too
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getBookById(
  IN ID VARCHAR(255)
) BEGIN
SELECT
  book.ISBN_id, book.title, book.picture_base64, GROUP_CONCAT(DISTINCT genres.genre) AS `genres`, GROUP_CONCAT(DISTINCT authors.author) AS `authors`, publishers.publisher_id, book.release_date, languages.lang, book.ISBN, book.description
FROM
  book
  INNER JOIN (
    books_genres_conn
    INNER JOIN genres ON genres.genre_id = books_genres_conn.genre_id
  ) ON book.ISBN_id = books_genres_conn.ISBN_id
  INNER JOIN (
    books_authors_conn
    INNER JOIN authors ON authors.author_id = books_authors_conn.author_id
  ) ON book.ISBN_id = books_authors_conn.ISBN_id
  INNER JOIN publishers ON publishers.publisher_id = book.publisher_id
  INNER JOIN languages ON languages.lang_id = book.lang_id
  INNER JOIN inventory ON inventory.ISBN_id = book.ISBN_id
WHERE
  FIND_IN_SET(CAST(book.ISBN_id AS VARCHAR(255)), ID)
GROUP BY 1;
END;//
DELIMITER ;


-- get all borrowed books borrowed by userID
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getBorrowedBooks(
  IN ID INT
) BEGIN
SELECT 
  inventory.book_id, GROUP_CONCAT(DISTINCT authors.author) AS `authors`,  book.ISBN, book.title, book.picture_base64, borrowings.end_date, borrowings.start_date, ( SELECT CASE WHEN COUNT(reservation.ISBN_id) > 0 THEN 'True' ELSE 'False' END FROM reservation WHERE reservation.ISBN_id = inventory.ISBN_id ) AS `meghosszabbithato`
FROM 
  users INNER JOIN( borrowings INNER JOIN( ((inventory INNER JOIN book ON book.ISBN_id = inventory.ISBN_id) INNER JOIN books_authors_conn on books_authors_conn.ISBN_id = book.ISBN_id) INNER JOIN authors on authors.author_id = books_authors_conn.author_id ) ON inventory.book_id = borrowings.book_id ) ON users.user_id = borrowings.user_id 
WHERE 
  users.user_id = ID AND borrowings.returned = 0 
GROUP BY borrowings.borrowing_id;
END;//
DELIMITER ;

-- returns books that were previously borrowed by the given user
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getPreviouslyBorrowedBooks(
  IN ID INT
) BEGIN
SELECT 
  inventory.book_id, GROUP_CONCAT(DISTINCT authors.author) AS `authors`,  book.ISBN, book.title, book.picture_base64, borrowings.end_date, borrowings.start_date
FROM 
  users INNER JOIN( borrowings INNER JOIN( ((inventory INNER JOIN book ON book.ISBN_id = inventory.ISBN_id) INNER JOIN books_authors_conn on books_authors_conn.ISBN_id = book.ISBN_id) INNER JOIN authors on authors.author_id = books_authors_conn.author_id ) ON inventory.book_id = borrowings.book_id ) ON users.user_id = borrowings.user_id 
WHERE 
  users.user_id = ID AND borrowings.returned = 1
GROUP BY borrowings.borrowing_id;
END;//
DELIMITER ;



-- checks if username is valid and sends password
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS sendPassword(
  IN username VARCHAR(255)
) BEGIN
IF((SELECT COUNT(users.user_id) FROM users WHERE users.username = username)=0) THEN
  SELECT 'not found' AS result;
ELSE
  SELECT (CASE WHEN (SELECT users.active FROM users WHERE users.username = username) THEN (SELECT users.password FROM users WHERE users.username = username AND users.active) ELSE 'inactive user' END) AS 'result';
END IF;
END;//
DELIMITER ;

-- for login get userid so we can set session
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getUserId(
  IN username VARCHAR(255)
) BEGIN
SELECT users.user_id FROM users WHERE users.username = username;
END;//
DELIMITER ;

-- gets user data
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getUser(
  IN userid INT
) BEGIN
SELECT users.surname, users.first_name, users.username, users.birth_date, users.birth_place, users.email, users.phone_number, users.address, users.mother_maiden_name, users.membership_end_date FROM users WHERE users.user_id = userid;
END;//
DELIMITER ;

-- returns if the book can be reserved or booked
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS checkAvailability(
 ISBN INT,
 userid INT
) BEGIN
DECLARE status VARCHAR(11) DEFAULT "";
SET status = (SELECT CASE WHEN (SELECT COUNT(borrowings.book_id) FROM borrowings INNER JOIN inventory ON borrowings.book_id = inventory.book_id WHERE inventory.ISBN_id = ISBN AND inventory.available AND borrowings.returned = 0) +( SELECT COUNT(booking.book_id) FROM booking INNER JOIN inventory ON booking.book_id = inventory.book_id WHERE inventory.ISBN_id = ISBN ) >= (SELECT COUNT(inventory.book_id) FROM inventory WHERE inventory.ISBN_id = ISBN) THEN 'reservation' ELSE 'booking' END);
SELECT status, IF(status='reservation', CASE WHEN (SELECT COUNT(reservation.ISBN_id) FROM reservation INNER JOIN users ON reservation.user_id = users.user_id WHERE users.user_id = userid)<=3 THEN 'true' ELSE 'false' END, CASE WHEN (SELECT COUNT(booking.book_id) FROM booking INNER JOIN users ON booking.user_id = users.user_id WHERE users.user_id = userid)<=3 THEN 'true' ELSE 'false' END) AS `available`;
END;//
DELIMITER;


-- reserves or books a book depending on avaliablity
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS addReservationOrBooking(
  ISBN INT,
  userid INT
) BEGIN
DECLARE _selected VARCHAR(20) DEFAULT '';
SET _selected = (SELECT CASE WHEN (SELECT COUNT(borrowings.book_id) FROM borrowings INNER JOIN inventory ON borrowings.book_id = inventory.book_id WHERE inventory.ISBN_id = ISBN AND inventory.available AND borrowings.returned = 0) +( SELECT COUNT(booking.book_id) FROM booking INNER JOIN inventory ON booking.book_id = inventory.book_id WHERE inventory.ISBN_id = ISBN ) >= (SELECT COUNT(inventory.book_id) FROM inventory WHERE inventory.ISBN_id = ISBN) THEN 'reservation' ELSE 'booking' END);
IF (_selected = 'booking') THEN 
BEGIN
  DECLARE _bookid INT DEFAULT '';
  SET _bookid = (SELECT inventory.book_id FROM inventory LEFT JOIN borrowings ON borrowings.book_id = inventory.book_id WHERE inventory.book_id NOT IN (SELECT borrowings.book_id FROM borrowings WHERE borrowings.returned = 0) AND inventory.book_id NOT IN (SELECT booking.book_id FROM booking) AND inventory.ISBN_id = ISBN AND inventory.available LIMIT 1);
	INSERT INTO booking(book_id, user_id, end_date) VALUES(_bookid, userid, CURRENT_DATE());
END;
ELSEIF (_selected = 'reservation') THEN 
  INSERT INTO reservation(ISBN_id, user_id) VALUES(ISBN, userid);
END IF;
SELECT _selected AS status;
END;//
DELIMITER ;


-- extends the return date
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS extendReturnDate(
  bookid INT,
  userid INT
) BEGIN
UPDATE borrowings SET borrowings.end_date = DATE_ADD(borrowings.end_date, INTERVAL (SELECT system_settings.lengthening_time FROM system_settings) DAY) WHERE borrowings.user_id = userid AND borrowings.book_id = bookid AND borrowings.returned = 0;
END;//
DELIMITER ;

-- check if return date can be extended
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS extendable(
  bookid INT,
  userid INT
) BEGIN
IF(((SELECT DATEDIFF(borrowings.end_date, borrowings.start_date) FROM borrowings WHERE borrowings.user_id = userid AND borrowings.book_id = bookid AND borrowings.returned = 0)<(SELECT system_settings.borrowing_time+system_settings.lengthening_time*system_settings.max_lengthenings FROM system_settings)) AND ((SELECT inventory.ISBN_id FROM inventory WHERE inventory.book_id = (SELECT borrowings.book_id FROM borrowings WHERE borrowings.user_id = userid AND borrowings.book_id = bookid AND borrowings.returned = 0)) NOT IN (SELECT reservation.ISBN_id FROM reservation))) THEN SELECT 'true'; ELSE SELECT 'false'; END IF;
END;//
DELIMITER ;

-- PROCEDURES FOR THE DESKTOP APP
-- Gets all books can be searched by book id and isbn
-- NOT TESTED NEED TO TEST IN APP
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getAllBooks(
  IN searchTerm VARCHAR(13),
  IN offseter INT,
  IN limiter INT
) BEGIN
SELECT book.ISBN, inventory.book_id, book.title FROM book INNER JOIN inventory ON inventory.ISBN_id = book.ISBN_id WHERE (inventory.book_id = searchTerm OR book.ISBN = searchTerm) OR searchTerm = '' LIMIT limiter OFFSET offseter;
END;//
DELIMITER ;

-- Add a book type
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS addBookType(
  IN ISBN VARCHAR(13),
  IN title VARCHAR(255),
  IN allGenres VARCHAR(255),
  IN allAuthors VARCHAR(255),
  IN publisherID INT,
  IN releaseDate DATE,
  IN lang VARCHAR(255),
  IN descript TEXT,
  IN picture TEXT
) BEGIN
DECLARE _next TEXT DEFAULT NULL;
DECLARE _nextlen INT DEFAULT NULL;
DECLARE _value TEXT DEFAULT NULL;
IF (SELECT COUNT(book.ISBN_id) FROM book WHERE book.ISBN = ISBN) = 0 THEN
	BEGIN
    	-- add book
        IF (SELECT COUNT(languages.lang_id) FROM languages WHERE languages.lang = lang) = 0 THEN
        	BEGIN
            	INSERT INTO languages(languages.lang) VALUES(lang);
             END;
        END IF;
        INSERT INTO book(book.ISBN, book.title, book.publisher_id, book.release_date, book.lang_id, book.description, book.picture_base64) VALUES(ISBN, title, pulisherID, releaseDate, (SELECT languages.lang_id FROM languages WHERE languages.lang = lang), descript, picture);
		
        -- ADD AUTHORS
        
        iterator1:
        LOOP
          -- exit the loop if the list seems empty or was null;
          -- this extra caution is necessary to avoid an endless loop in the proc.
          IF CHAR_LENGTH(TRIM(allAuthors)) = 0 OR allAuthors IS NULL THEN
            LEAVE iterator1;
          END IF;

          -- capture the next value from the list
          SET _next = SUBSTRING_INDEX(allAuthors,',',1);

          -- save the length of the captured value; we will need to remove this
          -- many characters + 1 from the beginning of the string 
          -- before the next iteration
          SET _nextlen = CHAR_LENGTH(_next);

          -- trim the value of leading and trailing spaces, in case of sloppy CSV strings
          SET _value = TRIM(_next);

          -- insert the extracted value into the target table
          IF (SELECT COUNT(authors.author_id) FROM authors WHERE authors.author = _value) = 0 THEN
        	BEGIN
            	INSERT INTO authors(authors.author) VALUES(_value);
             END;
          END IF;
          INSERT INTO books_authors_conn(books_authors_conn.ISBN_id, books_authors_conn.author_id) VALUES((SELECT book.ISBN_id FROM book WHERE book.ISBN = ISBN), (SELECT authors.author_id FROM authors WHERE authors.author = _value));

          -- rewrite the original string using the `INSERT()` string function,
          -- args are original string, start position, how many characters to remove, 
          -- and what to "insert" in their place (in this case, we "insert"
          -- an empty string, which removes _nextlen + 1 characters)
          SET allAuthors = INSERT(allAuthors,1,_nextlen + 1,'');
        END LOOP;
        
        -- ADD CATHEGORIES
        
        iterator2:
        LOOP
          -- exit the loop if the list seems empty or was null;
          -- this extra caution is necessary to avoid an endless loop in the proc.
          IF CHAR_LENGTH(TRIM(allGenres)) = 0 OR allGenres IS NULL THEN
            LEAVE iterator2;
          END IF;

          -- capture the next value from the list
          SET _next = SUBSTRING_INDEX(allGenres,',',1);

          -- save the length of the captured value; we will need to remove this
          -- many characters + 1 from the beginning of the string 
          -- before the next iteration
          SET _nextlen = CHAR_LENGTH(_next);

          -- trim the value of leading and trailing spaces, in case of sloppy CSV strings
          SET _value = TRIM(_next);

          -- insert the extracted value into the target table
          IF (SELECT COUNT(genres.genre_id) FROM genres WHERE genres.genre = _value) = 0 THEN
        	BEGIN
            	INSERT INTO genres(genres.genre) VALUES(_value);
             END;
          END IF;
		  INSERT INTO books_genres_conn(books_genres_conn.ISBN_id, books_genres_conn.genre_id) VALUES((SELECT book.ISBN_id FROM book WHERE book.ISBN = ISBN), (SELECT genres.genre_id FROM genres WHERE genres.genre = _value));
          -- rewrite the original string using the `INSERT()` string function,
          -- args are original string, start position, how many characters to remove, 
          -- and what to "insert" in their place (in this case, we "insert"
          -- an empty string, which removes _nextlen + 1 characters)
          SET allGenres = INSERT(allGenres,1,_nextlen + 1,'');
        END LOOP;
    END;
ELSE
	SELECT 'Already exists';
END IF;
END;//
DELIMITER ;

-- Add a book
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS addBook(
  IN ISBN VARCHAR(13)
) BEGIN
INSERT INTO inventory(inventory.ISBN_id, inventory.available) VALUES((SELECT book.ISBN_id FROM book WHERE book.ISBN = ISBN), 1);
END;//
DELIMITER ;

-- for desktop login
-- NEEDS TO BE TESTED
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS loginEmployee(
  IN username VARCHAR(255)
) BEGIN
SELECT employees.password FROM employees WHERE empl_name = username;
END;//
DELIMITER ;

-- Borrow a book
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS borrowBook(
  IN userID INT,
  IN bookID INT,
  IN emplID INT
) BEGIN
IF (bookID IN (SELECT booking.book_id FROM booking) AND (userID NOT IN (SELECT booking.user_id FROM booking WHERE booking.book_id = bookID))) THEN  
SELECT 'Már valaki lefoglalta ezt a könyvet';
ELSE
-- add an active borrowing
INSERT INTO borrowings(borrowings.book_id, borrowings.user_id, borrowings.empl_e, borrowings.start_date, borrowings.end_date, borrowings.returned) VALUES(bookID, userID, emplID, CURRENT_DATE(), (SELECT CURRENT_DATE()+ INTERVAL (SELECT system_settings.borrowing_time FROM system_settings) DAY), 0);
IF (bookID IN (SELECT booking.book_id FROM booking) AND (userID IN (SELECT booking.user_id FROM booking WHERE booking.book_id = bookID))) THEN 
DELETE FROM booking WHERE booking.book_id = bookID;
END IF;
END IF;
END;//
DELIMITER ;

-- Return a book
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS returnBook(
  IN userID INT,
  IN bookID INT,
  IN emplID INT
) BEGIN
-- check if it is late
IF (SELECT borrowings.end_date FROM borrowings WHERE borrowings.user_id = userID AND borrowings.book_id = bookID AND borrowings.returned = 0)-CURRENT_DATE()<0 THEN
SELECT (CURRENT_DATE()-(SELECT borrowings.end_date FROM borrowings WHERE borrowings.user_id = userID AND borrowings.book_id = bookID AND borrowings.returned = 0))*(SELECT system_settings.latency_fee FROM system_settings);
END IF;
-- update borrowings
UPDATE borrowings SET borrowings.returned = 1, borrowings.empl_e = emplID, borrowings.end_date = CURRENT_DATE() WHERE borrowings.user_id = userID AND borrowings.book_id = bookID AND borrowings.returned = 0;
-- add next reservation to booking if exists
IF ((SELECT COUNT(reservation.reservation_id) FROM reservation WHERE reservation.ISBN_id = (SELECT inventory.ISBN_id FROM inventory WHERE inventory.book_id = bookID AND inventory.available))>0) THEN
CALL addReservationOrBooking((SELECT inventory.ISBN_id FROM inventory WHERE inventory.book_id = bookID), (SELECT reservation.user_id FROM reservation WHERE reservation.ISBN_id = (SELECT inventory.ISBN_id FROM inventory WHERE inventory.book_id = bookID) ORDER BY reservation.reservation_id ASC LIMIT 1));
-- delete the shifted reservation
DELETE FROM reservation WHERE reservation.reservation_id = (SELECT reservation.reservation_id FROM reservation WHERE reservation.ISBN_id = (SELECT inventory.ISBN_id FROM inventory WHERE inventory.book_id = bookID) ORDER BY reservation.reservation_id ASC LIMIT 1);
END IF;
END;//
DELIMITER ;

-- adds a publisher
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS addPublisher(
  IN pubname VARCHAR(255),
  IN phone VARCHAR(255),
  IN email VARCHAR(255),
  IN webpage VARCHAR(255)
) BEGIN
IF ((SELECT publishers.name FROM publishers WHERE publishers.name = pubname) IS NULL) THEN 
	INSERT INTO publishers(publishers.name, publishers.phone, publishers.email, publishers.webpage) VALUES(pubname, phone, email, webpage); 
ELSE 
	SELECT "ilyen név már létezik"; 
END IF; 
END;//
DELIMITER ;

-- adds a user
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS addUser(
  IN surname VARCHAR(255), 
  IN firstname VARCHAR(255), 
  IN uname VARCHAR(255),
  IN birthdate DATE, 
  IN email VARCHAR(255),
  IN phone VARCHAR(255),
  IN pw VARBINARY(16),
  IN birthplace VARCHAR(255), 
  IN address VARCHAR(255),
  IN mmn VARBINARY(16) 
) BEGIN
IF ((SELECT users.user_id FROM users WHERE users.surname = surname AND users.first_name = firstname AND users.birth_date = birthdate AND users.birth_place = birthplace AND users.mother_maiden_name  = mmn) IS NULL) THEN 
	INSERT INTO users(users.surname, users.first_name, users.username, users.birth_date, users.membership_end_date, users.email, users.phone_number, users.password, users.birth_place, users.address, users.mother_maiden_name, users.active) VALUES(surname, firstname, uname ,birthdate, (SELECT CURRENT_DATE() - INTERVAL 1 DAY), email, phone, pw, birthplace, address, mmn, 1);
ELSE 
	SELECT "a személy már egyszer beregisztrált"; 
END IF; 
END;//
DELIMITER ;

-- adds an employee
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS addEmployee(
  IN uname VARCHAR(255),
  IN pw VARBINARY(16)
) BEGIN
IF ((SELECT employees.empl_id FROM employees WHERE employees.empl_name = uname AND employees.password = pw) IS NULL) THEN 
	INSERT INTO employees(employees.empl_name, employees.password) VALUES(uname, pw);
ELSE 
	SELECT "az alkalmazott már egyszer beregisztrált"; 
END IF; 
END;//
DELIMITER ;

-- renew membership (member for a year)
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS renewMembership(
  IN uname VARCHAR(255)
) BEGIN
	UPDATE users SET users.membership_end_date = CURRENT_DATE() + INTERVAL 1 YEAR WHERE users.username = uname;
END;//
DELIMITER ;
