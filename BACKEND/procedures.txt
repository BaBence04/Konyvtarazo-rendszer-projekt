-- procedure that lists books with filters applied
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS listBooksFiltered(
  IN title VARCHAR(255),
  IN genre VARCHAR(255),
  IN author VARCHAR(255),
  IN release_date VARCHAR(255),
  IN var_languages VARCHAR (255),
  IN var_ISBN VARCHAR(13),
  IN offseter INT,
  IN limiter INT
) BEGIN
CALL getBookById((SELECT
  GROUP_CONCAT(DISTINCT book.ISBN_id LIMIT limiter OFFSET offseter)
FROM
  book
  INNER JOIN (
    books_genres_conn
    INNER JOIN genres ON genres.genre_id = books_genres_conn.genre_id
  ) ON book.ISBN_id = books_genres_conn.ISBN_id
  INNER JOIN (
    books_authors_conn
    INNER JOIN authors ON authors.author_id = books_authors_conn.author_id
  ) ON book.ISBN_id = books_authors_conn.ISBN_id
  INNER JOIN publishers ON publishers.publisher_id = book.publisher_id
  INNER JOIN languages ON languages.lang_id = book.lang_id
  INNER JOIN inventory ON inventory.ISBN_id = book.ISBN_id
WHERE
  book.title LIKE CONCAT("%", title, "%")
  AND genres.genre LIKE CONCAT("%", genre, "%")
  AND authors.author LIKE CONCAT("%", author, "%")
  AND CAST(book.release_date AS VARCHAR(255)) LIKE CONCAT("%", release_date, "%")
  AND languages.lang LIKE CONCAT("%", var_languages, "%")
  AND book.ISBN LIKE CONCAT("%", var_ISBN, "%")
  AND inventory.available = TRUE

));
END;//
DELIMITER ;

-- get book by isbn
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getBookByISBN(
  IN ISBN VARCHAR(255)
) BEGIN
	CALL getBookById((SELECT book.ISBN_id FROM book WHERE book.ISBN = ISBN LIMIT 1));
END;//
DELIMITER ;

-- gets all genres
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getGenres(
) BEGIN
	SELECT genres.genre FROM genres;
END;//
DELIMITER ;

-- gets all genres
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getLangs(
) BEGIN
	SELECT languages.lang FROM languages;
END;//
DELIMITER ;

-- converts isbn to isbnid
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getIdFromISBN(
  IN ISBN VARCHAR(255)
) BEGIN
	SELECT book.ISBN_id FROM book WHERE book.ISBN = ISBN LIMIT 1;
END;//
DELIMITER ;

-- procedure, that gets every information abt a book by id
-- can be used for desktop app too
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getBookById(
  IN ID VARCHAR(255)
) BEGIN
SELECT
  book.ISBN_id, book.title, book.picture_base64, GROUP_CONCAT(DISTINCT genres.genre) AS `genres`, GROUP_CONCAT(DISTINCT authors.author) AS `authors`, publishers.publisher_id, book.release_date, languages.lang, book.ISBN, book.description
FROM
  book
  INNER JOIN (
    books_genres_conn
    INNER JOIN genres ON genres.genre_id = books_genres_conn.genre_id
  ) ON book.ISBN_id = books_genres_conn.ISBN_id
  INNER JOIN (
    books_authors_conn
    INNER JOIN authors ON authors.author_id = books_authors_conn.author_id
  ) ON book.ISBN_id = books_authors_conn.ISBN_id
  INNER JOIN publishers ON publishers.publisher_id = book.publisher_id
  INNER JOIN languages ON languages.lang_id = book.lang_id
  INNER JOIN inventory ON inventory.ISBN_id = book.ISBN_id
WHERE
  FIND_IN_SET(CAST(book.ISBN_id AS VARCHAR(255)), ID)
GROUP BY 1;
END;//
DELIMITER ;

-- get all booked and reserved book by userID
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getBookedAndReservedBooks(
  IN ID INT
) BEGIN
(SELECT book.title AS 'title', GROUP_CONCAT(DISTINCT authors.author) AS 'authors', 'booking' AS 'status', book.ISBN, booking.booking_id as `id` FROM booking INNER JOIN (inventory INNER JOIN (book INNER JOIN (books_authors_conn INNER JOIN authors ON books_authors_conn.author_id = authors.author_id) ON books_authors_conn.ISBN_id = book.ISBN_id) ON book.ISBN_id = inventory.ISBN_id) ON booking.book_id = inventory.book_id WHERE booking.user_id = ID GROUP BY booking.booking_id ORDER BY booking.booking_id DESC)
UNION ALL
(SELECT book.title, GROUP_CONCAT(DISTINCT authors.author), 'reservation', book.ISBN, reservation.reservation_id FROM reservation INNER JOIN (inventory INNER JOIN (book INNER JOIN (books_authors_conn INNER JOIN authors ON books_authors_conn.author_id = authors.author_id) ON books_authors_conn.ISBN_id = book.ISBN_id) ON inventory.ISBN_id = book.ISBN_id)ON reservation.ISBN_id = inventory.ISBN_id WHERE reservation.user_id = ID GROUP BY reservation.reservation_id ORDER BY reservation.reservation_id DESC);
END;//
DELIMITER ;

-- cancel reservation by id and userid check
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS cancelReservation(
  IN RESID INT,
  IN USID INT
) BEGIN
DELETE FROM reservation WHERE reservation.reservation_id = RESID AND reservation.user_id = USID;
END;//
DELIMITER ;

-- cancel booking by id and userid check
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS cancelBooking(
  IN BOOKID INT,
  IN USID INT
) BEGIN
DECLARE IDBook INT DEFAULT 0;
SET IDBook = (SELECT booking.book_id FROM booking WHERE booking.booking_id = BOOKID);
DELETE FROM booking WHERE booking.booking_id = BOOKID AND booking.user_id = USID;
IF ((SELECT COUNT(reservation.reservation_id) FROM reservation WHERE reservation.ISBN_id = (SELECT inventory.ISBN_id FROM inventory WHERE inventory.book_id = IDBook AND inventory.available))>0) THEN
-- out of sync error occur when calling this maybe we need to add it manually
-- CALL addReservationOrBooking((SELECT inventory.ISBN_id FROM inventory WHERE inventory.book_id = IDBook), (SELECT reservation.user_id FROM reservation WHERE reservation.ISBN_id = (SELECT inventory.ISBN_id FROM inventory WHERE inventory.book_id = IDBook) ORDER BY reservation.reservation_id ASC LIMIT 1));
-- adding manually 
INSERT INTO booking(booking.book_id, booking.user_id, booking.end_date) VALUES(IDBook, (SELECT reservation.user_id FROM reservation WHERE reservation.ISBN_id = (SELECT inventory.ISBN_id FROM inventory WHERE inventory.book_id = IDBook) ORDER BY reservation.reservation_id ASC LIMIT 1), CURRENT_DATE()+INTERVAL (SELECT system_settings.reservation_time FROM system_settings) DAY);
-- delete the shifted reservation
DELETE FROM reservation WHERE reservation.reservation_id = (SELECT reservation.reservation_id FROM reservation WHERE reservation.ISBN_id = (SELECT inventory.ISBN_id FROM inventory WHERE inventory.book_id = IDBook) ORDER BY reservation.reservation_id ASC LIMIT 1);
-- notify which user is now booked
SELECT booking.user_id FROM booking WHERE booking.book_id = IDBook;
END IF;
END;//
DELIMITER ;

-- get all borrowed books borrowed by userID
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getBorrowedBooks(
  IN ID INT
) BEGIN
SELECT 
  inventory.book_id, GROUP_CONCAT(DISTINCT authors.author) AS `authors`,  book.ISBN, book.title, book.picture_base64, borrowings.end_date, borrowings.start_date, ( SELECT CASE WHEN COUNT(reservation.ISBN_id) > 0 THEN 'True' ELSE 'False' END FROM reservation WHERE reservation.ISBN_id = inventory.ISBN_id ) AS `meghosszabbithato`, ((CURRENT_DATE()- borrowings.end_date)*(SELECT system_settings.latency_fee FROM system_settings)) AS `fizetendo`
FROM 
  users INNER JOIN( borrowings INNER JOIN( ((inventory INNER JOIN book ON book.ISBN_id = inventory.ISBN_id) INNER JOIN books_authors_conn on books_authors_conn.ISBN_id = book.ISBN_id) INNER JOIN authors on authors.author_id = books_authors_conn.author_id ) ON inventory.book_id = borrowings.book_id ) ON users.user_id = borrowings.user_id 
WHERE 
  users.user_id = ID AND borrowings.returned = 0 
GROUP BY borrowings.borrowing_id ORDER BY borrowings.start_date DESC;
END;//
DELIMITER ;

-- returns books that were previously borrowed by the given user
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getPreviouslyBorrowedBooks(
  IN ID INT
) BEGIN
SELECT 
  inventory.book_id, GROUP_CONCAT(DISTINCT authors.author) AS `authors`,  book.ISBN, book.title, book.picture_base64, borrowings.end_date, borrowings.start_date
FROM 
  users INNER JOIN( borrowings INNER JOIN( ((inventory INNER JOIN book ON book.ISBN_id = inventory.ISBN_id) INNER JOIN books_authors_conn on books_authors_conn.ISBN_id = book.ISBN_id) INNER JOIN authors on authors.author_id = books_authors_conn.author_id ) ON inventory.book_id = borrowings.book_id ) ON users.user_id = borrowings.user_id 
WHERE 
  users.user_id = ID AND borrowings.returned = 1
GROUP BY borrowings.borrowing_id;
END;//
DELIMITER ;

-- automatically deletes bookings that are not picked up or users membership expired and notifies next (kinézet: egy concated string ami [bookid], [deletedUserid], [newUserid -1 ha nincs ilyen könyvre igény], [expmember-ha a membership expired, notpicked-ha nem vették át];[next row of things])
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS deleteLateBookings()
BEGIN
DECLARE output VARCHAR(255) DEFAULT "";
-- delete lates
FOR bookID IN (SELECT booking.book_id, IF(users.membership_end_date<CURRENT_DATE(), 'expmember', 'notpicked') AS 'status' FROM booking INNER JOIN users ON users.user_id  = booking.user_id WHERE booking.end_date<CURRENT_DATE() OR users.membership_end_date<CURRENT_DATE())
DO
SET output = CONCAT(output, bookID.book_id, ',', (SELECT booking.user_id FROM booking WHERE booking.book_id = bookID.book_id));
DELETE FROM booking WHERE booking.book_id = bookID.book_id;
IF ((SELECT COUNT(reservation.reservation_id) FROM reservation WHERE reservation.ISBN_id = (SELECT inventory.ISBN_id FROM inventory WHERE inventory.book_id = bookID.book_id AND inventory.available))>0) THEN
-- insert if there is reservation for the book
INSERT INTO booking(booking.book_id, booking.user_id, booking.end_date) VALUES(bookID.book_id, (SELECT reservation.user_id FROM reservation WHERE reservation.ISBN_id = (SELECT inventory.ISBN_id FROM inventory WHERE inventory.book_id = bookID.book_id) ORDER BY reservation.reservation_id ASC LIMIT 1), CURRENT_DATE()+INTERVAL (SELECT system_settings.reservation_time FROM system_settings) DAY);
-- delete the shifted reservation
DELETE FROM reservation WHERE reservation.reservation_id = (SELECT reservation.reservation_id FROM reservation WHERE reservation.ISBN_id = (SELECT inventory.ISBN_id FROM inventory WHERE inventory.book_id = bookID.book_id) ORDER BY reservation.reservation_id ASC LIMIT 1);
-- notify which user is now booked
SET output = CONCAT(output, ',', (SELECT booking.user_id FROM booking WHERE booking.book_id = bookID.book_id));
ELSE
SET output = CONCAT(output, ',', '-1');
END IF;
SET output = CONCAT(output, ',', bookID.status, ';');
END FOR;
SELECT output;
END;//
DELIMITER ;

-- automatically deletes reservations where users membership expired and notifies next (kinézet: egy concated string ami [ISBN], [deletedUserid];[next row of things])
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS deleteLateReservations()
BEGIN
DECLARE output VARCHAR(255) DEFAULT "";
-- delete late reservations
FOR resID IN (SELECT reservation.reservation_id FROM reservation INNER JOIN users ON users.user_id = reservation.user_id WHERE users.membership_end_date<CURRENT_DATE())
DO
SET output = CONCAT(output, (SELECT reservation.ISBN_id FROM reservation WHERE reservation.reservation_id = resID.reservation_id), ',', (SELECT reservation.user_id FROM reservation WHERE reservation.reservation_id = resID.reservation_id), ';');
DELETE FROM reservation WHERE reservation.reservation_id = resID.reservation_id;
END FOR;
SELECT output;
END;//
DELIMITER ;

-- logs in user
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS loginUser(
  IN username VARCHAR(255),
  IN pw VARCHAR(255)
) BEGIN
IF((SELECT COUNT(users.user_id) FROM users WHERE users.username = username)=0) THEN
  SELECT 'not found' AS result;
ELSE
  SELECT CASE WHEN (users.active) THEN CASE WHEN (users.password = PASSWORD(pw)) THEN 'true' ELSE 'false' END END AS 'result', CASE WHEN users.membership_end_date<CURRENT_DATE() THEN 'false' ELSE 'true' END AS '' FROM users WHERE users.username = username;
END IF;
END;//
DELIMITER ;

-- for login get userid so we can set session
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getUserId(
  IN username VARCHAR(255)
) BEGIN
SELECT users.user_id FROM users WHERE users.username = username;
END;//
DELIMITER ;

-- update user details
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS updateUserDetails(
  IN userID INT,
  IN surname VARCHAR(255),
  IN first_name VARCHAR(255),
  IN birth_place VARCHAR(255),
  IN birth_date DATE,
  IN address VARCHAR(255),
  IN email VARCHAR(255),
  IN phone_num VARCHAR(255),
  IN mmn VARCHAR(255)
) BEGIN
UPDATE users SET users.surname = surname, users.first_name = first_name, users.birth_place = birth_place, users.birth_date = birth_date, users.address = address, users.email = email, users.phone_number = phone_num, users.membership_end_date = mmn WHERE users.user_id = userID;
END;//
DELIMITER ;

-- gets user data
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getUser(
  IN userid INT
) BEGIN
SELECT users.surname, users.first_name, users.username, users.birth_date, users.birth_place, users.email, users.phone_number, users.address, users.mother_maiden_name, users.membership_end_date FROM users WHERE users.user_id = userid;
END;//
DELIMITER ;

-- returns if the book can be reserved or booked
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS checkAvailability(
 ISBN INT,
 userid INT
) BEGIN
DECLARE status VARCHAR(11) DEFAULT "";
SET status = (SELECT CASE WHEN (SELECT COUNT(borrowings.book_id) FROM borrowings INNER JOIN inventory ON borrowings.book_id = inventory.book_id WHERE inventory.ISBN_id = ISBN AND inventory.available AND borrowings.returned = 0) +( SELECT COUNT(booking.book_id) FROM booking INNER JOIN inventory ON booking.book_id = inventory.book_id WHERE inventory.ISBN_id = ISBN ) >= (SELECT COUNT(inventory.book_id) FROM inventory WHERE inventory.ISBN_id = ISBN) THEN 'reservation' ELSE 'booking' END);
SELECT status, IF(status='reservation', CASE WHEN (SELECT COUNT(reservation.ISBN_id) FROM reservation INNER JOIN users ON reservation.user_id = users.user_id WHERE users.user_id = userid)<=3 AND (SELECT users.membership_end_date FROM users WHERE users.user_id = userid)>=CURRENT_DATE() THEN 'true' ELSE 'false' END, CASE WHEN (SELECT COUNT(booking.book_id) FROM booking INNER JOIN users ON booking.user_id = users.user_id WHERE users.user_id = userid)<=(SELECT system_settings.max_reservations FROM system_settings) AND (SELECT users.membership_end_date FROM users WHERE users.user_id = userid)>=CURRENT_DATE() THEN 'true' ELSE 'false' END) AS `available`;
END;//
DELIMITER;


-- reserves or books a book depending on avaliablity
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS addReservationOrBooking(
  ISBN INT,
  userid INT
) BEGIN
DECLARE _selected VARCHAR(20) DEFAULT '';
SET _selected = (SELECT CASE WHEN (SELECT COUNT(borrowings.book_id) FROM borrowings INNER JOIN inventory ON borrowings.book_id = inventory.book_id WHERE inventory.ISBN_id = ISBN AND inventory.available AND borrowings.returned = 0) +( SELECT COUNT(booking.book_id) FROM booking INNER JOIN inventory ON booking.book_id = inventory.book_id WHERE inventory.ISBN_id = ISBN ) >= (SELECT COUNT(inventory.book_id) FROM inventory WHERE inventory.ISBN_id = ISBN) THEN 'reservation' ELSE 'booking' END);
IF (_selected = 'booking') THEN 
BEGIN
  DECLARE _bookid INT DEFAULT '';
  SET _bookid = (SELECT inventory.book_id FROM inventory LEFT JOIN borrowings ON borrowings.book_id = inventory.book_id WHERE inventory.book_id NOT IN (SELECT borrowings.book_id FROM borrowings WHERE borrowings.returned = 0) AND inventory.book_id NOT IN (SELECT booking.book_id FROM booking) AND inventory.ISBN_id = ISBN AND inventory.available LIMIT 1);
	INSERT INTO booking(book_id, user_id, end_date) VALUES(_bookid, userid, CURRENT_DATE()+INTERVAL (SELECT system_settings.reservation_time FROM system_settings) DAY);
END;
ELSEIF (_selected = 'reservation') THEN 
  INSERT INTO reservation(ISBN_id, user_id) VALUES(ISBN, userid);
END IF;
SELECT _selected AS status;
END;//
DELIMITER ;


-- extends the return date
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS extendReturnDate(
  bookid INT,
  userid INT
) BEGIN
UPDATE borrowings SET borrowings.end_date = DATE_ADD(borrowings.end_date, INTERVAL (SELECT system_settings.lengthening_time FROM system_settings) DAY) WHERE borrowings.user_id = userid AND borrowings.book_id = bookid AND borrowings.returned = 0;
END;//
DELIMITER ;

-- check if return date can be extended
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS extendable(
  bookid INT,
  userid INT
) BEGIN
IF(((SELECT DATEDIFF(borrowings.end_date, borrowings.start_date) FROM borrowings WHERE borrowings.user_id = userid AND borrowings.book_id = bookid AND borrowings.returned = 0)<(SELECT system_settings.borrowing_time+system_settings.lengthening_time*system_settings.max_lengthenings FROM system_settings)) AND ((SELECT inventory.ISBN_id FROM inventory WHERE inventory.book_id = (SELECT borrowings.book_id FROM borrowings WHERE borrowings.user_id = userid AND borrowings.book_id = bookid AND borrowings.returned = 0)) NOT IN (SELECT reservation.ISBN_id FROM reservation))) THEN SELECT 'true'; ELSE SELECT 'false'; END IF;
END;//
DELIMITER ;

-- PROCEDURES FOR THE DESKTOP APP
-- Gets all books can be searched by book id and isbn
-- NOT TESTED NEED TO TEST IN APP
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getAllBooks(
  IN searchTerm VARCHAR(13),
  IN offseter INT,
  IN limiter INT
) BEGIN
SELECT book.ISBN, inventory.book_id, book.title FROM book INNER JOIN inventory ON inventory.ISBN_id = book.ISBN_id WHERE (inventory.book_id = searchTerm OR book.ISBN = searchTerm) OR searchTerm = '' LIMIT limiter OFFSET offseter;
END;//
DELIMITER ;

-- Add a book type
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS addBookType(
  IN ISBN VARCHAR(13),
  IN title VARCHAR(255),
  IN allGenres VARCHAR(255),
  IN allAuthors VARCHAR(255),
  IN publisherID INT,
  IN releaseDate DATE,
  IN lang VARCHAR(255),
  IN descript TEXT,
  IN picture TEXT
) BEGIN
DECLARE _next TEXT DEFAULT NULL;
DECLARE _nextlen INT DEFAULT NULL;
DECLARE _value TEXT DEFAULT NULL;
IF (SELECT COUNT(book.ISBN_id) FROM book WHERE book.ISBN = ISBN) = 0 THEN
	BEGIN
    	-- add book
        IF (SELECT COUNT(languages.lang_id) FROM languages WHERE languages.lang = lang) = 0 THEN
        	BEGIN
            	INSERT INTO languages(languages.lang) VALUES(lang);
             END;
        END IF;
        INSERT INTO book(book.ISBN, book.title, book.publisher_id, book.release_date, book.lang_id, book.description, book.picture_base64) VALUES(ISBN, title, pulisherID, releaseDate, (SELECT languages.lang_id FROM languages WHERE languages.lang = lang), descript, picture);
		
        -- ADD AUTHORS
        
        iterator1:
        LOOP
          -- exit the loop if the list seems empty or was null;
          -- this extra caution is necessary to avoid an endless loop in the proc.
          IF CHAR_LENGTH(TRIM(allAuthors)) = 0 OR allAuthors IS NULL THEN
            LEAVE iterator1;
          END IF;

          -- capture the next value from the list
          SET _next = SUBSTRING_INDEX(allAuthors,',',1);

          -- save the length of the captured value; we will need to remove this
          -- many characters + 1 from the beginning of the string 
          -- before the next iteration
          SET _nextlen = CHAR_LENGTH(_next);

          -- trim the value of leading and trailing spaces, in case of sloppy CSV strings
          SET _value = TRIM(_next);

          -- insert the extracted value into the target table
          IF (SELECT COUNT(authors.author_id) FROM authors WHERE authors.author = _value) = 0 THEN
        	BEGIN
            	INSERT INTO authors(authors.author) VALUES(_value);
             END;
          END IF;
          INSERT INTO books_authors_conn(books_authors_conn.ISBN_id, books_authors_conn.author_id) VALUES((SELECT book.ISBN_id FROM book WHERE book.ISBN = ISBN), (SELECT authors.author_id FROM authors WHERE authors.author = _value));

          -- rewrite the original string using the `INSERT()` string function,
          -- args are original string, start position, how many characters to remove, 
          -- and what to "insert" in their place (in this case, we "insert"
          -- an empty string, which removes _nextlen + 1 characters)
          SET allAuthors = INSERT(allAuthors,1,_nextlen + 1,'');
        END LOOP;
        
        -- ADD CATHEGORIES
        
        iterator2:
        LOOP
          -- exit the loop if the list seems empty or was null;
          -- this extra caution is necessary to avoid an endless loop in the proc.
          IF CHAR_LENGTH(TRIM(allGenres)) = 0 OR allGenres IS NULL THEN
            LEAVE iterator2;
          END IF;

          -- capture the next value from the list
          SET _next = SUBSTRING_INDEX(allGenres,',',1);

          -- save the length of the captured value; we will need to remove this
          -- many characters + 1 from the beginning of the string 
          -- before the next iteration
          SET _nextlen = CHAR_LENGTH(_next);

          -- trim the value of leading and trailing spaces, in case of sloppy CSV strings
          SET _value = TRIM(_next);

          -- insert the extracted value into the target table
          IF (SELECT COUNT(genres.genre_id) FROM genres WHERE genres.genre = _value) = 0 THEN
        	BEGIN
            	INSERT INTO genres(genres.genre) VALUES(_value);
             END;
          END IF;
		  INSERT INTO books_genres_conn(books_genres_conn.ISBN_id, books_genres_conn.genre_id) VALUES((SELECT book.ISBN_id FROM book WHERE book.ISBN = ISBN), (SELECT genres.genre_id FROM genres WHERE genres.genre = _value));
          -- rewrite the original string using the `INSERT()` string function,
          -- args are original string, start position, how many characters to remove, 
          -- and what to "insert" in their place (in this case, we "insert"
          -- an empty string, which removes _nextlen + 1 characters)
          SET allGenres = INSERT(allGenres,1,_nextlen + 1,'');
        END LOOP;
    END;
ELSE
	SELECT 'Already exists';
END IF;
END;//
DELIMITER ;

-- Add a book
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS addBook(
  IN ISBN VARCHAR(13)
) BEGIN
INSERT INTO inventory(inventory.ISBN_id, inventory.available) VALUES((SELECT book.ISBN_id FROM book WHERE book.ISBN = ISBN), 1);
END;//
DELIMITER ;

-- for desktop login
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS loginEmployee(
  IN username VARCHAR(255), 
  IN pw VARCHAR(255)
) BEGIN
SELECT CASE WHEN (SELECT employees.password FROM employees WHERE employees.empl_uname = username) = PASSWORD(pw) THEN 'true' ELSE 'false' END AS 'info';
END;//
DELIMITER ;

-- gets all users for database
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getUsers(
IN searchTerm VARCHAR(255)
)
BEGIN
IF(searchTerm = "") THEN
SELECT users.surname, users.first_name, users.username FROM users;
ELSE
SELECT users.surname, users.first_name, users.username FROM users WHERE users.surname LIKE CONCAT("%", searchTerm, "%") OR users.first_name LIKE CONCAT("%", searchTerm, "%") OR users.username LIKE CONCAT("%", searchTerm, "%"); 
END IF;
END;//
DELIMITER ;

-- gets all books with search term for database
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS getBooks(
IN searchTerm VARCHAR(255)
)
BEGIN
IF(searchTerm = "") THEN
SELECT inventory.book_id, book.ISBN, book.title FROM inventory INNER JOIN book ON book.ISBN_id = inventory.ISBN_id;
ELSE
SELECT inventory.book_id, book.ISBN, book.title FROM inventory INNER JOIN book ON book.ISBN_id = inventory.ISBN_id WHERE inventory.ISBN_id LIKE CONCAT("%", searchTerm, "%") OR book.title LIKE CONCAT("%", searchTerm, "%"); 
END IF;
END;//
DELIMITER ;

-- Borrow a book
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS borrowBook(
  IN userID INT,
  IN bookID INT,
  IN emplID INT
) BEGIN
IF (bookID IN (SELECT booking.book_id FROM booking) AND (userID NOT IN (SELECT booking.user_id FROM booking WHERE booking.book_id = bookID))) THEN  
SELECT 'Már valaki lefoglalta ezt a könyvet';
ELSE
-- add an active borrowing
INSERT INTO borrowings(borrowings.book_id, borrowings.user_id, borrowings.empl_e, borrowings.start_date, borrowings.end_date, borrowings.returned) VALUES(bookID, userID, emplID, CURRENT_DATE(), (SELECT CURRENT_DATE()+ INTERVAL (SELECT system_settings.borrowing_time FROM system_settings) DAY), 0);
IF (bookID IN (SELECT booking.book_id FROM booking) AND (userID IN (SELECT booking.user_id FROM booking WHERE booking.book_id = bookID))) THEN 
DELETE FROM booking WHERE booking.book_id = bookID;
END IF;
END IF;
END;//
DELIMITER ;

-- Return a book
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS returnBook(
  IN userID INT,
  IN bookID INT,
  IN emplID INT
) BEGIN
-- check if it is late
-- modifying so it works with the notification 
DECLARE late INT DEFAULT 0;
IF (SELECT borrowings.end_date FROM borrowings WHERE borrowings.user_id = userID AND borrowings.book_id = bookID AND borrowings.returned = 0)-CURRENT_DATE()<0 THEN
SET late = (SELECT (CURRENT_DATE()-(SELECT borrowings.end_date FROM borrowings WHERE borrowings.user_id = userID AND borrowings.book_id = bookID AND borrowings.returned = 0))*(SELECT system_settings.latency_fee FROM system_settings));
END IF;
-- update borrowings
UPDATE borrowings SET borrowings.returned = 1, borrowings.empl_e = emplID, borrowings.end_date = CURRENT_DATE() WHERE borrowings.user_id = userID AND borrowings.book_id = bookID AND borrowings.returned = 0;
-- add next reservation to booking if exists
IF ((SELECT COUNT(reservation.reservation_id) FROM reservation WHERE reservation.ISBN_id = (SELECT inventory.ISBN_id FROM inventory WHERE inventory.book_id = bookID AND inventory.available))>0) THEN
-- out of sync error occur when calling this maybe we need to add it manually
-- CALL addReservationOrBooking((SELECT inventory.ISBN_id FROM inventory WHERE inventory.book_id = bookID), (SELECT reservation.user_id FROM reservation WHERE reservation.ISBN_id = (SELECT inventory.ISBN_id FROM inventory WHERE inventory.book_id = bookID) ORDER BY reservation.reservation_id ASC LIMIT 1));
-- adding manually 
INSERT INTO booking(booking.book_id, booking.user_id, booking.end_date) VALUES(bookID, (SELECT reservation.user_id FROM reservation WHERE reservation.ISBN_id = (SELECT inventory.ISBN_id FROM inventory WHERE inventory.book_id = bookID) ORDER BY reservation.reservation_id ASC LIMIT 1), CURRENT_DATE()+INTERVAL (SELECT system_settings.reservation_time FROM system_settings) DAY);
-- delete the shifted reservation
DELETE FROM reservation WHERE reservation.reservation_id = (SELECT reservation.reservation_id FROM reservation WHERE reservation.ISBN_id = (SELECT inventory.ISBN_id FROM inventory WHERE inventory.book_id = bookID) ORDER BY reservation.reservation_id ASC LIMIT 1);
SELECT booking.user_id AS 'new' FROM booking WHERE booking.book_id = bookID;
ELSE
-- will return -1 if nobody is in the reservation 
SELECT -1 AS 'new';
END IF;
END;//
DELIMITER ;

-- gets return info
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS returnInfo(
  IN bookID INT
) BEGIN
IF ((SELECT borrowings.end_date FROM borrowings WHERE borrowings.book_id = bookID AND borrowings.returned = 0)<CURRENT_DATE()) THEN
SELECT book.title AS 'title', book.ISBN AS 'ISBN', CONCAT(users.first_name, " ", users.surname) AS 'name', users.user_id AS 'user', borrowings.end_date AS 'end', DATEDIFF(CURRENT_DATE(), borrowings.end_date) AS 'late', (DATEDIFF(CURRENT_DATE(), borrowings.end_date)*(SELECT system_settings.latency_fee FROM system_settings)) AS 'fee' FROM users INNER JOIN (borrowings INNER JOIN (inventory INNER JOIN book ON book.ISBN_id = inventory.ISBN_id) ON borrowings.book_id = inventory.book_id) ON users.user_id = borrowings.user_id WHERE borrowings.book_id = bookID AND borrowings.returned = 0; ELSE
SELECT book.title AS 'title', book.ISBN AS 'ISBN', CONCAT(users.first_name, " ", users.surname) AS 'name', users.user_id AS 'user', borrowings.end_date AS 'end' FROM users INNER JOIN (borrowings INNER JOIN (inventory INNER JOIN book ON book.ISBN_id = inventory.ISBN_id) ON borrowings.book_id = inventory.book_id) ON users.user_id = borrowings.user_id WHERE borrowings.book_id = bookID AND borrowings.returned = 0;
END IF;
END;//
DELIMITER ;

-- adds a publisher
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS addPublisher(
  IN pubname VARCHAR(255),
  IN phone VARCHAR(255),
  IN email VARCHAR(255),
  IN webpage VARCHAR(255)
) BEGIN
IF ((SELECT publishers.name FROM publishers WHERE publishers.name = pubname) IS NULL) THEN 
	INSERT INTO publishers(publishers.name, publishers.phone, publishers.email, publishers.webpage) VALUES(pubname, phone, email, webpage); 
ELSE 
	SELECT "ilyen név már létezik"; 
END IF; 
END;//
DELIMITER ;

-- adds a user
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS addUser(
  IN surname VARCHAR(255), 
  IN firstname VARCHAR(255), 
  IN uname VARCHAR(255),
  IN birthdate DATE, 
  IN email VARCHAR(255),
  IN phone VARCHAR(255),
  IN pw VARBINARY(16),
  IN birthplace VARCHAR(255), 
  IN address VARCHAR(255),
  IN mmn VARBINARY(16) 
) BEGIN
IF ((SELECT users.user_id FROM users WHERE users.surname = surname AND users.first_name = firstname AND users.birth_date = birthdate AND users.birth_place = birthplace AND users.mother_maiden_name  = mmn) IS NULL) THEN 
	INSERT INTO users(users.surname, users.first_name, users.username, users.birth_date, users.membership_end_date, users.email, users.phone_number, users.password, users.birth_place, users.address, users.mother_maiden_name, users.active) VALUES(surname, firstname, uname ,birthdate, (SELECT CURRENT_DATE() - INTERVAL 1 DAY), email, phone, pw, birthplace, address, mmn, 1);
ELSE 
	SELECT "a személy már egyszer beregisztrált"; 
END IF; 
END;//
DELIMITER ;

-- adds an employee
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS addEmployee(
  IN uname VARCHAR(255),
  IN pw VARBINARY(16)
) BEGIN
IF ((SELECT employees.empl_id FROM employees WHERE employees.empl_name = uname AND employees.password = pw) IS NULL) THEN 
	INSERT INTO employees(employees.empl_name, employees.password) VALUES(uname, pw);
ELSE 
	SELECT "az alkalmazott már egyszer beregisztrált"; 
END IF; 
END;//
DELIMITER ;

-- renew membership (member for a year)
DELIMITER //
CREATE PROCEDURE IF NOT EXISTS renewMembership(
  IN uname VARCHAR(255)
) BEGIN
	UPDATE users SET users.membership_end_date = CURRENT_DATE() + INTERVAL 1 YEAR WHERE users.username = uname;
END;//
DELIMITER ;
